Every single entity on the battlefield—from a Marine to a mineral patch, from a Pylon to a flying Overlord—is represented in your code as a `Unit` object. This is the most fundamental data structure in `python-sc2`. It is both a data container and an actor: it holds all the information about an entity, and it is the object you use to issue it commands.

Mastering the `Unit` object is non-negotiable. It is how you will read the battlefield, manage your base, and control your army.

#### **A Mental Model: The `Unit` as a Class**

Think of every unit in the game as an instance of a class. The object holds the unit's current state and provides methods to change that state.

```
       +------------------------------------+
       |         Unit (e.g., Marine)        |
       |====================================|
       |          -- Properties --          |  <-- Data you can READ
       |   name: "Marine"                   |
       |   health: 45                       |
       |   position: Point2(34.5, 67.5)     |
       |   is_idle: True                    |
       |   ...                              |
       |------------------------------------|
       |           -- Methods --            |  <-- Actions you can CALL
       |   + attack(target)                 |
       |   + move(position)                 |
       |   + hold_position()                |
       |   ...                              |
       +------------------------------------+
```

#### **How to Get a `Unit` Object**

You will almost never create a `Unit` object manually. Instead, you will retrieve them from the game state using the helper properties on `self`.

```python
# Get a single Unit object representing your first townhall.
my_townhall = self.townhalls.first

# Get a single Unit object representing a random idle worker.
idle_worker = self.workers.idle.random_or(None)

# Loop through a collection of Unit objects.
for marine in self.units(UnitTypeId.MARINE):
    # 'marine' is a Unit object.
    if marine.is_idle:
        print(f"Found an idle marine with tag {marine.tag}")
```

---

#### **Key `Unit` Attributes: A Developer's Reference**

Once you have a `Unit` object, you can inspect its attributes to make decisions.

| Category | Attribute | Data Type | Use Case in a Project |
| :--- | :--- | :--- | :--- |
| **Identity** | `name`<br />`type_id`<br />`tag` | `str`<br />`UnitTypeId`<br />`int` | **`type_id` is best for checks.** Use `tag` to uniquely identify a unit throughout a match. |
| **Vitals** | `health`, `health_max`<br />`shield`, `shield_max`<br />`energy`, `energy_max` | `float` | Check health to decide if a unit should retreat. Check energy to see if a caster can use an ability. |
| **Position** | `position`<br />`radius` | `Point2`<br />`float` | `position` is essential for all movement and distance calculations. |
| **Combat** | `weapon_cooldown`<br />`is_attacking` | `float`<br />`bool` | `weapon_cooldown` is the key to advanced micro-management like stutter-stepping. |
| **State Flags**| `is_idle`<br />`is_flying`<br />`is_powered`<br />`is_burrowed` | `bool` | These booleans are the most common conditions in `if` statements for managing unit behavior. |
| **Ownership**| `is_yours`<br />`is_enemy` | `bool` | Crucial for distinguishing your units from the opponent's. |

---

#### **A Developer's Checklist for Using a `Unit`**

When your code gets a `Unit` object, this is your thought process:

-   [ ] **1. Identify It:** What is this unit? (`if unit.type_id == UnitTypeId.MARINE:`)
-   [ ] **2. Check Its State:** Is it doing what it should be? (`if unit.is_idle:`)
-   [ ] **3. Assess Its Condition:** Is it healthy enough to fight? (`if (unit.health / unit.health_max) < 0.4:`)
-   [ ] **4. Give It an Order:** If it's not doing the right thing, issue a command (`unit.attack(...)`).

---

#### **Code Example: The Field Commander Bot**

This bot demonstrates the full "Sense-Think-Act" cycle on individual `Unit` objects. It finds idle Marines and sends them to attack, and pulls back any Marine that is badly damaged.

```python
# field_commander_bot.py

import sc2
from sc2.bot_ai import BotAI
from sc2.ids.unit_typeid import UnitTypeId
from sc2.player import Bot, Computer
from sc2.race import Race, Difficulty

class FieldCommanderBot(BotAI):
    """
    Demonstrates inspecting and commanding individual Unit objects.
    """
    async def on_step(self, iteration: int):
        # We need a target to attack.
        target = self.enemy_start_locations[0]
        if self.enemy_structures.exists:
            target = self.enemy_structures.random.position

        # Loop through all of our Marine unit objects.
        for marine in self.units(UnitTypeId.MARINE):
            # SENSE: Check the health and state of this specific marine.
            is_hurt = marine.health / marine.health_max < 0.5
            is_idle = marine.is_idle

            # THINK & ACT: Make a decision based on the unit's state.
            if is_hurt:
                # If hurt, pull it back to our start location.
                # The 'move' command is on the Unit object.
                marine.move(self.start_location)
            elif is_idle:
                # If idle and healthy, send it to attack.
                # The 'attack' command is on the Unit object.
                marine.attack(target)


if __name__ == "__main__":
    sc2.run_game(
        sc2.maps.get("BlackburnAIE"),
        [
            Bot(Race.Terran, FieldCommanderBot()),
            Computer(Race.Zerg, Difficulty.Easy)
        ],
        realtime=True,
    )
```