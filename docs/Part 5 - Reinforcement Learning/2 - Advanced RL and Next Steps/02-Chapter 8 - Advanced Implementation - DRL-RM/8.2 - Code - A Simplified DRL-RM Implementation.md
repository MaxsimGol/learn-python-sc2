This file provides a functional, albeit simplified, implementation of the "generalized agent" concept. It is designed to handle a variable number of units by encoding the game state into an entity list and using a decomposed action space.

This code serves as a foundational example of how to structure an agent that can operate in a more complex and dynamic environment than our previous, specialized bots.

---

#### **The Code: `drl_rm_bot.py`**

```python
# drl_rm_bot.py

import numpy as np
import gymnasium as gym
from gymnasium.spaces import Box, MultiDiscrete
import queue

from sc2.bot_ai import BotAI
from sc2.race import Terran
from sc2.ids.unit_typeid import UnitTypeId
from sc2.units import Units
from sc2_gym_env import SC2GymEnv

# --- Environment Constants ---
MAX_UNITS = 50  # The maximum number of units to include in our observation
NUM_UNIT_FEATURES = 5  # The number of features describing each unit

class DRL_RM_Bot(BotAI):
    """
    The BotAI for our simplified DRL-RM agent. It encodes the game state
    into an entity list and decodes actions from the RL agent.
    """
    def __init__(self, action_queue, obs_queue):
        super().__init__()
        self.action_queue = action_queue
        self.obs_queue = obs_queue
        self.race = Terran

    def _encode_state(self) -> np.ndarray:
        """Encodes the current game state into a padded matrix of unit features."""
        
        # Combine our units and visible enemy units into one list
        all_units = self.units + self.enemy_units
        all_units = all_units.sorted(lambda u: u.tag) # Sort for consistency
        
        # Manually create a feature matrix
        encoded_units = np.zeros((len(all_units), NUM_UNIT_FEATURES), dtype=np.float32)

        # A simple mapping of unit types to integers
        type_map = {UnitTypeId.MARINE: 1, UnitTypeId.SCV: 2, UnitTypeId.ZERGLING: 3}

        for i, unit in enumerate(all_units):
            encoded_units[i] = [
                type_map.get(unit.type_id, 0), # Use 0 for unknown types
                unit.health_percentage,
                unit.position.x / self.game_info.map_size.width,
                unit.position.y / self.game_info.map_size.height,
                1.0 if unit.is_mine else 0.0
            ]
        
        # Pad the observation with zeros up to MAX_UNITS
        obs = np.zeros((MAX_UNITS, NUM_UNIT_FEATURES), dtype=np.float32)
        num_observed = min(len(encoded_units), MAX_UNITS)
        if num_observed > 0:
            obs[:num_observed] = encoded_units[:num_observed]
            
        return obs

    async def _decode_and_execute_action(self, action: list[int]):
        """Decodes the agent's action and issues a command."""
        actor_idx, ability_id, target_idx = action
        
        my_units = self.units.sorted(lambda u: u.tag)
        all_units = (my_units + self.enemy_units.sorted(lambda u: u.tag))

        # --- Safety Checks ---
        # Ensure the selected actor and target are valid indices
        if not (0 <= actor_idx < len(my_units)): return
        if not (0 <= target_idx < len(all_units)): return

        actor = my_units[actor_idx]
        target = all_units[target_idx]

        # Ability 0: Move, Ability 1: Attack
        if ability_id == 0:
            await self.do(actor.move(target.position))
        elif ability_id == 1:
            await self.do(actor.attack(target))
        
    async def on_step(self, iteration: int):
        if iteration % 8 == 0:
            # 1. DECODE AND EXECUTE ACTION
            try:
                action = self.action_queue.get_nowait()
                await self._decode_and_execute_action(action)
            except queue.Empty:
                pass # No action from agent
            
            # 2. ENCODE STATE AND SEND OBSERVATION
            observation = self._encode_state()
            terminated = self.townhalls.amount == 0 # End if we lose
            self.obs_queue.put((observation, 0.1, terminated, False, {})) # Simple reward
            
            if terminated:
                await self.client.leave()


class DRL_RM_Env(SC2GymEnv):
    """The Gymnasium Wrapper for the DRL-RM bot."""
    def __init__(self):
        super().__init__(bot_class=DRL_RM_Bot, map_name="AcropolisLE")
        
        # Observation Space: A 2D matrix of (MAX_UNITS, NUM_FEATURES)
        self.observation_space = Box(
            low=0, high=1,
            shape=(MAX_UNITS, NUM_UNIT_FEATURES),
            dtype=np.float32
        )
        
        # Action Space: A vector of 3 integers for the decomposed action
        self.action_space = MultiDiscrete([
            MAX_UNITS,        # Index of the friendly unit to act as the "actor"
            2,                # Index of the ability to use (0=Move, 1=Attack)
            MAX_UNITS * 2     # Index of the target unit (friendly or enemy)
        ])
```