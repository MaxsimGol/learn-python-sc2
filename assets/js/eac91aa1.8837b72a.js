"use strict";(self.webpackChunkmy_framework_docs=self.webpackChunkmy_framework_docs||[]).push([[4317],{4250:(e,r,n)=>{n.r(r),n.d(r,{assets:()=>d,contentTitle:()=>o,default:()=>u,frontMatter:()=>a,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"Part 2 - Core Concepts/Chapter 5 - Issuing Commands - Actions/5.4 - Production- Training Units and Researching Upgrades","title":"5.4 - Production- Training Units and Researching Upgrades","description":"Once your base includes production structures, your bot\'s focus shifts to converting resources into military power. The commands for training units (.train()) and researching upgrades (.research()) are simple Commands, not Queries. They are non-blocking and should be called directly without await.","source":"@site/docs/Part 2 - Core Concepts/Chapter 5 - Issuing Commands - Actions/5.4 - Production- Training Units and Researching Upgrades.md","sourceDirName":"Part 2 - Core Concepts/Chapter 5 - Issuing Commands - Actions","slug":"/Part 2 - Core Concepts/Chapter 5 - Issuing Commands - Actions/5.4 - Production- Training Units and Researching Upgrades","permalink":"/learn-python-sc2/docs/Part 2 - Core Concepts/Chapter 5 - Issuing Commands - Actions/5.4 - Production- Training Units and Researching Upgrades","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"5.3 - Worker Commands- Gather and Build","permalink":"/learn-python-sc2/docs/Part 2 - Core Concepts/Chapter 5 - Issuing Commands - Actions/5.3 - Worker Commands- Gather and Build"},"next":{"title":"5.5 - Using Special Abilities","permalink":"/learn-python-sc2/docs/Part 2 - Core Concepts/Chapter 5 - Issuing Commands - Actions/5.5 - Using Special Abilities"}}');var t=n(4848),i=n(8453);const a={},o=void 0,d={},c=[{value:"<strong>The Complete Production Lifecycle</strong>",id:"the-complete-production-lifecycle",level:4},{value:"<strong>Deep Dive 1- Tracking Completed Upgrades with <code>self.state.upgrades</code></strong>",id:"deep-dive-1--tracking-completed-upgrades-with-selfstateupgrades",level:4},{value:"<strong>Deep Dive 2- Verifying Tech with <code>self.tech_requirement_progress()</code></strong>",id:"deep-dive-2--verifying-tech-with-selftech_requirement_progress",level:4},{value:"<strong>Code Example- The Quartermaster Bot (with Armory)</strong>",id:"code-example--the-quartermaster-bot-with-armory",level:4}];function l(e){const r={code:"code",h4:"h4",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(r.p,{children:["Once your base includes production structures, your bot's focus shifts to converting resources into military power. The commands for training units (",(0,t.jsx)(r.code,{children:".train()"}),") and researching upgrades (",(0,t.jsx)(r.code,{children:".research()"}),") are simple ",(0,t.jsx)(r.strong,{children:"Commands"}),", not ",(0,t.jsx)(r.strong,{children:"Queries"}),". They are non-blocking and should be called directly without ",(0,t.jsx)(r.code,{children:"await"}),"."]}),"\n",(0,t.jsx)(r.p,{children:"However, to use them effectively, your bot must follow a complete, five-step validation lifecycle to ensure every production request is possible, non-redundant, and technologically feasible."}),"\n",(0,t.jsx)(r.h4,{id:"the-complete-production-lifecycle",children:(0,t.jsx)(r.strong,{children:"The Complete Production Lifecycle"})}),"\n",(0,t.jsx)(r.p,{children:"A robust production system must validate a request against all five of these conditions before issuing a command."}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{children:"(You want to produce something...)\r\n           |\r\n           v\r\n.---  1. IS IT POSSIBLE? (Economic Check) ---.\r\n| - self.can_afford()                      |\r\n| - self.supply_left > 0                   | (For units)\r\n`------------------------------------------`\r\n           | (Yes)\r\n           v\r\n.--- 2. IS IT REDUNDANT? (State Check) ---.\r\n| - self.already_pending() == 0          |\r\n| - upgrade not in self.state.upgrades   | (For upgrades)\r\n`--------------------------------------`\r\n           | (No)\r\n           v\r\n.--- 3. DO I HAVE THE TECH? (Requirement Check) ---.\r\n| - self.tech_requirement_progress(ITEM) == 1.0  |\r\n`------------------------------------------------`\r\n           | (Yes)\r\n           v\r\n.--- 4. WHERE CAN I MAKE IT? (Building Check) ---.\r\n| - building = self.structures(TYPE).ready.idle.first |\r\n`-----------------------------------------------`\r\n           | (Building exists)\r\n           v\r\n.---- 5. ISSUE COMMAND ----.\r\n| - building.train(UNIT)  |\r\n| - building.research(UPGRADE) |\r\n`-----------------------`\n"})}),"\n",(0,t.jsx)(r.hr,{}),"\n",(0,t.jsx)(r.h4,{id:"deep-dive-1--tracking-completed-upgrades-with-selfstateupgrades",children:(0,t.jsxs)(r.strong,{children:["Deep Dive 1- Tracking Completed Upgrades with ",(0,t.jsx)(r.code,{children:"self.state.upgrades"})]})}),"\n",(0,t.jsxs)(r.ul,{children:["\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:(0,t.jsx)(r.code,{children:"self.state.upgrades"})}),": This is a Python ",(0,t.jsx)(r.code,{children:"set"})," containing the ",(0,t.jsx)(r.code,{children:"UpgradeId"})," of every upgrade your bot has successfully completed."]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"The Check:"})," ",(0,t.jsx)(r.code,{children:"upgrade_id not in self.state.upgrades"})," is a highly efficient boolean check that returns ",(0,t.jsx)(r.code,{children:"True"})," if you do not yet have the upgrade."]}),"\n"]}),"\n",(0,t.jsx)(r.h4,{id:"deep-dive-2--verifying-tech-with-selftech_requirement_progress",children:(0,t.jsxs)(r.strong,{children:["Deep Dive 2- Verifying Tech with ",(0,t.jsx)(r.code,{children:"self.tech_requirement_progress()"})]})}),"\n",(0,t.jsxs)(r.ul,{children:["\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:(0,t.jsx)(r.code,{children:"self.tech_requirement_progress(item_id)"})}),': This is a query that asks, "What percentage (from 0.0 to 1.0) of the tech requirements for this unit or upgrade have I met?"']}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"The Check:"})," You must verify ",(0,t.jsx)(r.code,{children:"self.tech_requirement_progress(item_id) == 1.0"})," before attempting to produce any unit or upgrade that has a dependency (e.g., checking for an Armory before researching Level 2 weapons)."]}),"\n"]}),"\n",(0,t.jsx)(r.hr,{}),"\n",(0,t.jsx)(r.h4,{id:"code-example--the-quartermaster-bot-with-armory",children:(0,t.jsx)(r.strong,{children:"Code Example- The Quartermaster Bot (with Armory)"})}),"\n",(0,t.jsx)(r.p,{children:"This bot demonstrates the complete five-step lifecycle. It builds an Armory and checks for it as a tech requirement before attempting to research Level 2 upgrades."}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-python",children:'# quartermaster_bot.py\r\n\r\nfrom sc2 import maps\r\nfrom sc2.bot_ai import BotAI\r\nfrom sc2.data import Difficulty, Race\r\nfrom sc2.main import run_game\r\nfrom sc2.player import Bot, Computer\r\nfrom sc2.ids.unit_typeid import UnitTypeId\r\nfrom sc2.ids.upgrade_id import UpgradeId\r\n\r\n\r\nclass QuartermasterBot(BotAI):\r\n    """A bot that correctly manages production and research requests, including advanced tech."""\r\n\r\n    async def on_step(self, iteration: int):\r\n        # A safety check: if we have no townhalls, we can\'t do anything, so we exit early.\r\n        if not self.townhalls:\r\n            return\r\n\r\n        # It\'s good practice to handle worker distribution first, as it\'s fundamental to the economy.\r\n        # This is awaited as it might involve commands to gather resources.\r\n        await self.distribute_workers()\r\n\r\n        # These are manager functions that contain our core production logic.\r\n        # They are simple function calls, not awaited, because the commands inside them\r\n        # (like .train() and .research()) are non-blocking.\r\n        self.manage_worker_production()\r\n        self.manage_unit_production()\r\n        self.manage_research()\r\n        # This function must be awaited because it contains .build() commands, which are async queries.\r\n        await self.build_tech_structures()\r\n\r\n    def manage_worker_production(self):\r\n        """Trains SCVs from any available idle command center."""\r\n        # This block follows the production lifecycle for an SCV.\r\n        # 1. Economic Check: self.can_afford()\r\n        # 2. State Check: self.workers.amount < limit\r\n        # 3. Building Check: self.townhalls.ready.idle.exists\r\n        # The optimal 22 workers per town hall fully saturates a base for maximum income.\r\n        #  By assigning 16 workers to minerals (2 for each of the 8 patches).\r\n        #  6 workers to gas (3 for each of the 2 geysers), which prevents any worker inefficiency from queuing.\r\n        if (\r\n            self.workers.amount < (self.townhalls.amount * 22)\r\n            and self.can_afford(UnitTypeId.SCV)\r\n            and self.townhalls.ready.idle.exists\r\n        ):\r\n            # 5. Issue Command: .train() is a non-blocking command.\r\n            self.townhalls.ready.idle.first.train(UnitTypeId.SCV)\r\n\r\n    def manage_unit_production(self):\r\n        """Trains one marine at a time from an available barracks."""\r\n        # 4. Building Check: First, ensure an eligible building exists.\r\n        if self.structures(UnitTypeId.BARRACKS).ready.idle.exists:\r\n            # 1. Economic Check: self.can_afford()\r\n            # 2. Redundancy Check: self.already_pending() == 0 ensures we don\'t queue endless marines.\r\n            if (\r\n                self.can_afford(UnitTypeId.MARINE)\r\n                and self.already_pending(UnitTypeId.MARINE) == 0\r\n            ):\r\n                # 5. Issue Command: .train() is a non-blocking command.\r\n                self.structures(UnitTypeId.BARRACKS).ready.idle.first.train(\r\n                    UnitTypeId.MARINE\r\n                )\r\n\r\n    def manage_research(self):\r\n        """Researches the next available infantry weapons upgrade."""\r\n        # 4. Building Check: Ensure a ready and idle Engineering Bay exists.\r\n        if not self.structures(UnitTypeId.ENGINEERINGBAY).ready.idle.exists:\r\n            return\r\n\r\n        upgrades_in_order = [\r\n            UpgradeId.TERRANINFANTRYWEAPONSLEVEL1,\r\n            UpgradeId.TERRANINFANTRYWEAPONSLEVEL2,\r\n            UpgradeId.TERRANINFANTRYWEAPONSLEVEL3,\r\n        ]\r\n\r\n        eng_bay = self.structures(UnitTypeId.ENGINEERINGBAY).ready.idle.first\r\n\r\n        for upgrade_id in upgrades_in_order:\r\n            # This combines all checks: economic, redundancy, and now, tech requirements.\r\n            if (\r\n                self.can_afford(upgrade_id)\r\n                and self.already_pending_upgrade(upgrade_id) == 0\r\n                and upgrade_id not in self.state.upgrades\r\n                # 3. Tech Check: Crucial for Level 2 and 3 upgrades.\r\n                and self.tech_requirement_progress(upgrade_id) == 1.0\r\n            ):\r\n                # 5. Issue Command: .research() is a non-blocking command.\r\n                eng_bay.research(upgrade_id)\r\n                # Use \'break\' to issue only one research command per step.\r\n                break\r\n\r\n    async def build_tech_structures(self):\r\n        """A helper to build necessary structures in a logical order."""\r\n        # This function uses self.build(), which is an async query, so it MUST be awaited.\r\n        if self.supply_left < 5 and not self.already_pending(UnitTypeId.SUPPLYDEPOT):\r\n            if self.can_afford(UnitTypeId.SUPPLYDEPOT):\r\n                await self.build(\r\n                    UnitTypeId.SUPPLYDEPOT,\r\n                    near=self.start_location.towards(self.game_info.map_center, 5),\r\n                )\r\n\r\n        # We check for a completed Supply Depot as the tech requirement for a Barracks.\r\n        if self.structures(UnitTypeId.SUPPLYDEPOT).ready.exists:\r\n            if not self.structures(\r\n                UnitTypeId.BARRACKS\r\n            ).exists and not self.already_pending(UnitTypeId.BARRACKS):\r\n                if self.can_afford(UnitTypeId.BARRACKS):\r\n                    await self.build(\r\n                        UnitTypeId.BARRACKS,\r\n                        near=self.start_location.towards(self.game_info.map_center, 8),\r\n                    )\r\n\r\n        # Check for a completed Barracks before building gas, Eng Bay, or a Factory.\r\n        if self.structures(UnitTypeId.BARRACKS).ready.exists:\r\n            # Build refineries on vespene geysers if we have fewer than 2.\r\n            if self.structures(UnitTypeId.REFINERY).amount < 2:\r\n                if self.can_afford(UnitTypeId.REFINERY):\r\n                    # Find all vespene geysers near our starting townhall.\r\n                    for geyser in self.vespene_geyser.closer_than(\r\n                        10.0, self.townhalls.first\r\n                    ):\r\n                        # Make sure we haven\'t already built a refinery on this specific geyser.\r\n                        if (\r\n                            not self.structures(UnitTypeId.REFINERY)\r\n                            .closer_than(1.0, geyser)\r\n                            .exists\r\n                        ):\r\n                            # Issue the build command ON the geyser.\r\n                            await self.build(UnitTypeId.REFINERY, near=geyser)\r\n                            break\r\n\r\n            # Build an Engineering Bay for upgrades.\r\n            if not self.structures(\r\n                UnitTypeId.ENGINEERINGBAY\r\n            ) and not self.already_pending(UnitTypeId.ENGINEERINGBAY):\r\n                if self.can_afford(UnitTypeId.ENGINEERINGBAY):\r\n                    await self.build(\r\n                        UnitTypeId.ENGINEERINGBAY,\r\n                        near=self.start_location.towards(self.game_info.map_center, 10),\r\n                    )\r\n\r\n            # Build a Factory, which is the prerequisite for an Armory.\r\n            if not self.structures(\r\n                UnitTypeId.FACTORY\r\n            ).exists and not self.already_pending(UnitTypeId.FACTORY):\r\n                if self.can_afford(UnitTypeId.FACTORY):\r\n                    await self.build(\r\n                        UnitTypeId.FACTORY,\r\n                        near=self.start_location.towards(self.game_info.map_center, 12),\r\n                    )\r\n\r\n        # Build an Armory, which requires a FACTORY.\r\n        if self.structures(UnitTypeId.FACTORY).ready.exists:\r\n            if not self.structures(\r\n                UnitTypeId.ARMORY\r\n            ).exists and not self.already_pending(UnitTypeId.ARMORY):\r\n                if self.can_afford(UnitTypeId.ARMORY):\r\n                    await self.build(\r\n                        UnitTypeId.ARMORY,\r\n                        near=self.start_location.towards(self.game_info.map_center, 14),\r\n                    )\r\n\r\n\r\nif __name__ == "__main__":\r\n    run_game(\r\n        maps.get("AbyssalReefLE"),\r\n        [Bot(Race.Terran, QuartermasterBot()), Computer(Race.Zerg, Difficulty.Easy)],\r\n        realtime=False,\r\n    )\n'})})]})}function u(e={}){const{wrapper:r}={...(0,i.R)(),...e.components};return r?(0,t.jsx)(r,{...e,children:(0,t.jsx)(l,{...e})}):l(e)}},8453:(e,r,n)=>{n.d(r,{R:()=>a,x:()=>o});var s=n(6540);const t={},i=s.createContext(t);function a(e){const r=s.useContext(i);return s.useMemo((function(){return"function"==typeof e?e(r):{...r,...e}}),[r,e])}function o(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:a(e.components),s.createElement(i.Provider,{value:r},e.children)}}}]);