"use strict";(self.webpackChunkmy_framework_docs=self.webpackChunkmy_framework_docs||[]).push([[4317],{4250:(e,r,n)=>{n.r(r),n.d(r,{assets:()=>d,contentTitle:()=>o,default:()=>u,frontMatter:()=>a,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"Part 2 - Core Concepts/Chapter 5 - Issuing Commands - Actions/5.4 - Production- Training Units and Researching Upgrades","title":"5.4 - Production- Training Units and Researching Upgrades","description":"Once your base includes production structures, your bot\'s focus shifts to converting resources into military power. The commands for training units (.train()) and researching upgrades (.research()) are simple Commands. They are non-blocking and should be called directly without await.","source":"@site/docs/Part 2 - Core Concepts/Chapter 5 - Issuing Commands - Actions/5.4 - Production- Training Units and Researching Upgrades.md","sourceDirName":"Part 2 - Core Concepts/Chapter 5 - Issuing Commands - Actions","slug":"/Part 2 - Core Concepts/Chapter 5 - Issuing Commands - Actions/5.4 - Production- Training Units and Researching Upgrades","permalink":"/learn-python-sc2/docs/Part 2 - Core Concepts/Chapter 5 - Issuing Commands - Actions/5.4 - Production- Training Units and Researching Upgrades","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"5.3 - Worker Commands- Gather and Build","permalink":"/learn-python-sc2/docs/Part 2 - Core Concepts/Chapter 5 - Issuing Commands - Actions/5.3 - Worker Commands- Gather and Build"},"next":{"title":"5.5 - Using Special Abilities","permalink":"/learn-python-sc2/docs/Part 2 - Core Concepts/Chapter 5 - Issuing Commands - Actions/5.5 - Using Special Abilities"}}');var t=n(4848),i=n(8453);const a={},o=void 0,d={},c=[{value:"<strong>The Complete Production Lifecycle</strong>",id:"the-complete-production-lifecycle",level:4},{value:"<strong>Deep Dive 1- Tracking Completed Upgrades with <code>self.state.upgrades</code></strong>",id:"deep-dive-1--tracking-completed-upgrades-with-selfstateupgrades",level:4},{value:"<strong>Deep Dive 2- Verifying Tech with <code>self.tech_requirement_progress()</code></strong>",id:"deep-dive-2--verifying-tech-with-selftech_requirement_progress",level:4},{value:"<strong>Code Example- The Quartermaster Bot (Corrected and Robust)</strong>",id:"code-example--the-quartermaster-bot-corrected-and-robust",level:4}];function l(e){const r={code:"code",h4:"h4",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(r.p,{children:["Once your base includes production structures, your bot's focus shifts to converting resources into military power. The commands for training units (",(0,t.jsx)(r.code,{children:".train()"}),") and researching upgrades (",(0,t.jsx)(r.code,{children:".research()"}),") are simple ",(0,t.jsx)(r.strong,{children:"Commands"}),". They are non-blocking and should be called directly without ",(0,t.jsx)(r.code,{children:"await"}),"."]}),"\n",(0,t.jsx)(r.p,{children:"However, to use them effectively, your bot must follow a complete, five-step validation lifecycle to ensure every production request is possible, non-redundant, and technologically feasible."}),"\n",(0,t.jsx)(r.h4,{id:"the-complete-production-lifecycle",children:(0,t.jsx)(r.strong,{children:"The Complete Production Lifecycle"})}),"\n",(0,t.jsx)(r.p,{children:"A robust production system must validate a request against all five of these conditions before issuing a command."}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{children:"(You want to produce something...)\r\n           |\r\n           v\r\n.---  1. IS IT POSSIBLE? (Economic Check) ---.\r\n| - self.can_afford()                      |\r\n| - self.supply_left > 0                   | (For units)\r\n`------------------------------------------`\r\n           | (Yes)\r\n           v\r\n.--- 2. IS IT REDUNDANT? (State Check) ---.\r\n| - self.already_pending() == 0          |\r\n| - upgrade not in self.state.upgrades   | (For upgrades)\r\n`--------------------------------------`\r\n           | (No)\r\n           v\r\n.--- 3. DO I HAVE THE TECH? (Requirement Check) ---.\r\n| - self.tech_requirement_progress(ITEM) == 1.0  |  <-- THE CRITICAL STEP\r\n`------------------------------------------------`\r\n           | (Yes)\r\n           v\r\n.--- 4. WHERE CAN I MAKE IT? (Building Check) ---.\r\n| - building = self.structures(TYPE).ready.idle.first |\r\n`-----------------------------------------------`\r\n           | (Building exists)\r\n           v\r\n.---- 5. ISSUE COMMAND ----.\r\n| - building.train(UNIT)  |\r\n| - building.research(UPGRADE) |\r\n`-----------------------`\n"})}),"\n",(0,t.jsx)(r.hr,{}),"\n",(0,t.jsx)(r.h4,{id:"deep-dive-1--tracking-completed-upgrades-with-selfstateupgrades",children:(0,t.jsxs)(r.strong,{children:["Deep Dive 1- Tracking Completed Upgrades with ",(0,t.jsx)(r.code,{children:"self.state.upgrades"})]})}),"\n",(0,t.jsxs)(r.p,{children:["This property is used in ",(0,t.jsx)(r.strong,{children:"Step 2 (Redundancy Check)"}),"."]}),"\n",(0,t.jsxs)(r.ul,{children:["\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"What it is:"})," ",(0,t.jsx)(r.code,{children:"self.state.upgrades"})," is a Python ",(0,t.jsx)(r.code,{children:"set"})," that contains the ",(0,t.jsx)(r.code,{children:"UpgradeId"})," of every upgrade your bot has successfully completed."]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"The Check:"})," ",(0,t.jsx)(r.code,{children:"upgrade_id not in self.state.upgrades"})," is a highly efficient boolean check that returns ",(0,t.jsx)(r.code,{children:"True"})," if you do not yet have the upgrade."]}),"\n"]}),"\n",(0,t.jsx)(r.h4,{id:"deep-dive-2--verifying-tech-with-selftech_requirement_progress",children:(0,t.jsxs)(r.strong,{children:["Deep Dive 2- Verifying Tech with ",(0,t.jsx)(r.code,{children:"self.tech_requirement_progress()"})]})}),"\n",(0,t.jsxs)(r.p,{children:["This function is used in ",(0,t.jsx)(r.strong,{children:"Step 3 (Tech Requirement Check)"})," and is essential for preventing your bot from getting stuck."]}),"\n",(0,t.jsxs)(r.ul,{children:["\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"What it is:"})," ",(0,t.jsx)(r.code,{children:"self.tech_requirement_progress(item_id)"}),' is a query that asks, "What percentage (from 0.0 to 1.0) of the tech requirements for this unit or upgrade have I met?"']}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"How it works:"})," It takes a ",(0,t.jsx)(r.code,{children:"UnitTypeId"})," or ",(0,t.jsx)(r.code,{children:"UpgradeId"})," and returns ",(0,t.jsx)(r.code,{children:"1.0"})," only if you have all the necessary prerequisite buildings. For example, to train a Marauder, you need a Barracks with a Tech Lab attached. If you only have the Barracks, the progress will be less than ",(0,t.jsx)(r.code,{children:"1.0"}),"."]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"The Check:"})," You must verify ",(0,t.jsx)(r.code,{children:"self.tech_requirement_progress(item_id) == 1.0"})," before attempting to produce any unit or upgrade that has a dependency."]}),"\n"]}),"\n",(0,t.jsx)(r.hr,{}),"\n",(0,t.jsx)(r.h4,{id:"code-example--the-quartermaster-bot-corrected-and-robust",children:(0,t.jsx)(r.strong,{children:"Code Example- The Quartermaster Bot (Corrected and Robust)"})}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-python",children:'# quartermaster_bot_final.py\r\n\r\nfrom sc2 import maps\r\nfrom sc2.bot_ai import BotAI\r\nfrom sc2.data import Difficulty, Race\r\nfrom sc2.main import run_game\r\nfrom sc2.player import Bot, Computer\r\nfrom sc2.ids.unit_typeid import UnitTypeId\r\nfrom sc2.ids.upgrade_id import UpgradeId\r\nfrom sc2.ids.ability_id import AbilityId\r\n\r\nclass QuartermasterBot(BotAI):\r\n    """\r\n    A bot that correctly manages production using the full 5-step lifecycle.\r\n    """\r\n    async def on_step(self, iteration: int):\r\n        if not self.townhalls:\r\n            return\r\n\r\n        await self.distribute_workers()\r\n        self.manage_production()\r\n        await self.build_infrastructure()\r\n\r\n    def manage_production(self):\r\n        """A single manager for all production decisions."""\r\n        # Worker Production\r\n        if self.can_afford(UnitTypeId.SCV) and self.townhalls.ready.idle and self.workers.amount < 44:\r\n            self.townhalls.ready.idle.first.train(UnitTypeId.SCV)\r\n\r\n        # Army Production (Marauders)\r\n        for barracks in self.structures(UnitTypeId.BARRACKS).ready.idle:\r\n            # STEP 3: Check Tech Requirement\r\n            if self.tech_requirement_progress(UnitTypeId.MARAUDER) == 1.0:\r\n                # Steps 1 & 2: Check affordability and redundancy\r\n                if self.can_afford(UnitTypeId.MARAUDER) and self.already_pending(UnitTypeId.MARAUDER) < 2:\r\n                    # Step 5: Issue Command\r\n                    barracks.train(UnitTypeId.MARAUDER)\r\n\r\n        # Research\r\n        self.manage_research()\r\n\r\n    def manage_research(self):\r\n        """Researches infantry upgrades in order."""\r\n        eng_bay = self.structures(UnitTypeId.ENGINEERINGBAY).ready.idle.first\r\n        if not eng_bay:\r\n            return\r\n            \r\n        # STEP 3: Tech requirement for Level 2 is having an Armory.\r\n        if self.tech_requirement_progress(UpgradeId.TERRANINFANTRYWEAPONSLEVEL2) == 1.0:\r\n            if self.can_afford(UpgradeId.TERRANINFANTRYWEAPONSLEVEL2) and not self.already_pending_upgrade(UpgradeId.TERRANINFANTRYWEAPONSLEVEL2):\r\n                eng_bay.research(UpgradeId.TERRANINFANTRYWEAPONSLEVEL2)\r\n        elif self.can_afford(UpgradeId.TERRANINFANTRYWEAPONSLEVEL1) and not self.already_pending_upgrade(UpgradeId.TERRANINFANTRYWEAPONSLEVEL1) and UpgradeId.TERRANINFANTRYWEAPONSLEVEL1 not in self.state.upgrades:\r\n            eng_bay.research(UpgradeId.TERRANINFANTRYWEAPONSLEVEL1)\r\n\r\n    async def build_infrastructure(self):\r\n        """Builds all necessary structures and add-ons."""\r\n        # Build Depots\r\n        if self.supply_left < 5 and not self.already_pending(UnitTypeId.SUPPLYDEPOT):\r\n            if self.can_afford(UnitTypeId.SUPPLYDEPOT):\r\n                await self.build(UnitTypeId.SUPPLYDEPOT, near=self.start_location.towards(self.game_info.map_center, 5))\r\n\r\n        # Build Barracks\r\n        if self.structures(UnitTypeId.SUPPLYDEPOT).ready.exists and self.structures(UnitTypeId.BARRACKS).amount < 2:\r\n            if self.can_afford(UnitTypeId.BARRACKS):\r\n                await self.build(UnitTypeId.BARRACKS, near=self.start_location.towards(self.game_info.map_center, 8))\r\n\r\n        # Build Tech Labs on Barracks for Marauders\r\n        for barracks in self.structures(UnitTypeId.BARRACKS).ready.idle:\r\n            # Check if there\'s no add-on and we can afford a Tech Lab\r\n            if not barracks.has_add_on and self.can_afford(UnitTypeId.TECHLAB):\r\n                barracks(AbilityId.BUILD_TECHLAB)\r\n                \r\n        # Build Engineering Bay\r\n        if self.structures(UnitTypeId.BARRACKS).ready and not self.structures(UnitTypeId.ENGINEERINGBAY):\r\n            if self.can_afford(UnitTypeId.ENGINEERINGBAY):\r\n                await self.build(UnitTypeId.ENGINEERINGBAY, near=self.start_location.towards(self.game_info.map_center, 10))\r\n        \r\n        # Build Armory (tech requirement for Level 2 upgrades)\r\n        if self.structures(UnitTypeId.ENGINEERINGBAY).ready and not self.structures(UnitTypeId.ARMORY):\r\n             if self.can_afford(UnitTypeId.ARMORY):\r\n                await self.build(UnitTypeId.ARMORY, near=self.start_location.towards(self.game_info.map_center, 12))\r\n\r\n\r\nif __name__ == "__main__":\r\n    run_game(\r\n        maps.get("AbyssalReefLE"),\r\n        [Bot(Race.Terran, QuartermasterBot()), Computer(Race.Zerg, Difficulty.Easy)],\r\n        realtime=True,\r\n    )\n'})})]})}function u(e={}){const{wrapper:r}={...(0,i.R)(),...e.components};return r?(0,t.jsx)(r,{...e,children:(0,t.jsx)(l,{...e})}):l(e)}},8453:(e,r,n)=>{n.d(r,{R:()=>a,x:()=>o});var s=n(6540);const t={},i=s.createContext(t);function a(e){const r=s.useContext(i);return s.useMemo((function(){return"function"==typeof e?e(r):{...r,...e}}),[r,e])}function o(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:a(e.components),s.createElement(i.Provider,{value:r},e.children)}}}]);