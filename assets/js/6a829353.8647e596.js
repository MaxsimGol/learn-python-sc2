"use strict";(self.webpackChunkmy_framework_docs=self.webpackChunkmy_framework_docs||[]).push([[4782],{5215:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>c,contentTitle:()=>i,default:()=>m,frontMatter:()=>a,metadata:()=>t,toc:()=>l});const t=JSON.parse('{"id":"Part 5 - Reinforcement Learning/Foundations of Reinforcement Learning/Chapter 2 - Setting Up the RL Environment/2.2 - Code - The Reusable SC2GymEnv Wrapper","title":"2.2 - Code - The Reusable SC2GymEnv Wrapper","description":"This file provides the complete, reusable implementation of the SC2GymEnv class. This class is the architectural cornerstone of our project, acting as the adapter that allows the synchronous stable-baselines3 library to communicate with the asynchronous python-sc2 game engine.","source":"@site/docs/Part 5 - Reinforcement Learning/1 - Foundations of Reinforcement Learning/Chapter 2 - Setting Up the RL Environment/2.2 - Code - The Reusable SC2GymEnv Wrapper.md","sourceDirName":"Part 5 - Reinforcement Learning/1 - Foundations of Reinforcement Learning/Chapter 2 - Setting Up the RL Environment","slug":"/Part 5 - Reinforcement Learning/Foundations of Reinforcement Learning/Chapter 2 - Setting Up the RL Environment/2.2 - Code - The Reusable SC2GymEnv Wrapper","permalink":"/learn-python-sc2/docs/Part 5 - Reinforcement Learning/Foundations of Reinforcement Learning/Chapter 2 - Setting Up the RL Environment/2.2 - Code - The Reusable SC2GymEnv Wrapper","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"2.1 - Installing RL Libraries","permalink":"/learn-python-sc2/docs/Part 5 - Reinforcement Learning/Foundations of Reinforcement Learning/Chapter 2 - Setting Up the RL Environment/2.1 - Installing RL Libraries"},"next":{"title":"3.1 - Goal - Learning a Single Economic Task","permalink":"/learn-python-sc2/docs/Part 5 - Reinforcement Learning/Foundations of Reinforcement Learning/Chapter 3 - The Worker Bot/3.1 - Goal - Learning a Single Economic Task"}}');var s=r(4848),o=r(8453);const a={},i=void 0,c={},l=[{value:"<strong>Class Responsibilities</strong>",id:"class-responsibilities",level:4}];function p(e){const n={code:"code",h4:"h4",hr:"hr",input:"input",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.p,{children:["This file provides the complete, reusable implementation of the ",(0,s.jsx)(n.code,{children:"SC2GymEnv"})," class. This class is the architectural cornerstone of our project, acting as the adapter that allows the synchronous ",(0,s.jsx)(n.code,{children:"stable-baselines3"})," library to communicate with the asynchronous ",(0,s.jsx)(n.code,{children:"python-sc2"})," game engine."]}),"\n",(0,s.jsxs)(n.p,{children:["Save this code as ",(0,s.jsx)(n.code,{children:"sc2_gym_env.py"}),". It will serve as the base class for all specific RL environments we create."]}),"\n",(0,s.jsx)(n.h4,{id:"class-responsibilities",children:(0,s.jsx)(n.strong,{children:"Class Responsibilities"})}),"\n",(0,s.jsxs)(n.ul,{className:"contains-task-list",children:["\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",checked:!0,disabled:!0})," ",(0,s.jsx)(n.strong,{children:"API Adherence:"})," Implements the standard ",(0,s.jsx)(n.code,{children:"gymnasium.Env"})," interface."]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",checked:!0,disabled:!0})," ",(0,s.jsx)(n.strong,{children:"Process Management:"})," Manages the lifecycle of the ",(0,s.jsx)(n.code,{children:"python-sc2"})," game process, including startup and cleanup."]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",checked:!0,disabled:!0})," ",(0,s.jsx)(n.strong,{children:"Communication Bridge:"})," Orchestrates the flow of actions and observations between the two processes using ",(0,s.jsx)(n.code,{children:"multiprocessing"})," queues."]}),"\n"]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.code,{children:"sc2_gym_env.py"})})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'import gymnasium as gym\r\nimport multiprocessing as mp\r\nfrom typing import Optional, Type, Tuple, Any\r\n\r\nfrom sc2.bot_ai import BotAI\r\nfrom sc2.data import Race, Difficulty\r\nfrom sc2.main import run_game\r\nfrom sc2 import maps\r\nfrom sc2.player import Bot, Computer\r\n\r\n\r\n# Define a more specific type hint for items passed through the observation queue.\r\n# This tuple represents: (observation, reward, terminated, truncated, info)\r\nObservationQueueItem = Tuple[Any, float, bool, bool, dict]\r\n\r\nclass SC2GymEnv(gym.Env):\r\n    """\r\n    A generic Gymnasium wrapper for the StarCraft II environment.\r\n\r\n    This class acts as a bridge between a synchronous RL agent (stable-baselines3)\r\n    and the asynchronous python-sc2 library. It runs the game in a separate\r\n    process and facilitates communication via multiprocessing queues.\r\n    """\r\n\r\n    def __init__(\r\n        self,\r\n        bot_class: Type[BotAI],\r\n        map_name: str,\r\n        bot_race: Race,\r\n        opponent_race: Race = Race.Random,\r\n        difficulty: Difficulty = Difficulty.Easy\r\n    ):\r\n        """\r\n        Initializes the SC2 Gymnasium environment.\r\n\r\n        Args:\r\n            bot_class: The user-defined BotAI class to be run in the game process.\r\n            map_name: The name of the StarCraft II map to be used.\r\n            bot_race: The race of the agent\'s bot.\r\n            opponent_race: The race of the computer opponent.\r\n            difficulty: The difficulty of the computer opponent.\r\n        """\r\n        super().__init__()\r\n        self.bot_class = bot_class\r\n        self.map_name = map_name\r\n        self.bot_race = bot_race\r\n        self.opponent_race = opponent_race\r\n        self.difficulty = difficulty\r\n        \r\n        # Queues for inter-process communication\r\n        self.action_queue: mp.Queue = mp.Queue()\r\n        self.obs_queue: mp.Queue[ObservationQueueItem] = mp.Queue()\r\n        \r\n        self.game_process: Optional[mp.Process] = None\r\n\r\n    def reset(\r\n        self, *, seed: Optional[int] = None, options: Optional[dict] = None\r\n    ) -> Tuple[Any, dict]:\r\n        """\r\n        Resets the environment to start a new episode.\r\n\r\n        Terminates any existing game process, starts a fresh one, and waits\r\n        for the initial observation from the game.\r\n        """\r\n        # It\'s required to call the superclass\'s reset method for proper seeding\r\n        super().reset(seed=seed)\r\n\r\n        if self.game_process and self.game_process.is_alive():\r\n            self.game_process.terminate()\r\n\r\n        self.game_process = mp.Process(\r\n            target=self._run_game_process,\r\n            args=(\r\n                self.bot_class,\r\n                self.map_name,\r\n                self.bot_race,\r\n                self.opponent_race,\r\n                self.difficulty,\r\n                self.action_queue,\r\n                self.obs_queue\r\n            )\r\n        )\r\n        self.game_process.start()\r\n        \r\n        # Block and wait for the initial observation from the new game process\r\n        initial_obs, _, _, _, info = self.obs_queue.get()\r\n        return initial_obs, info\r\n\r\n    def step(self, action: Any) -> ObservationQueueItem:\r\n        """\r\n        Executes one time step within the environment.\r\n\r\n        The agent\'s action is sent to the game process, and the wrapper\r\n        waits for the resulting state information to be returned.\r\n        """\r\n        self.action_queue.put(action)\r\n        return self.obs_queue.get()\r\n\r\n    def close(self):\r\n        """Performs any necessary cleanup. Terminates the game process."""\r\n        if self.game_process and self.game_process.is_alive():\r\n            self.game_process.terminate()\r\n\r\n    @staticmethod\r\n    def _run_game_process(\r\n        bot_class: Type[BotAI],\r\n        map_name: str,\r\n        bot_race: Race,\r\n        opponent_race: Race,\r\n        difficulty: Difficulty,\r\n        action_queue: mp.Queue,\r\n        obs_queue: mp.Queue[ObservationQueueItem]\r\n    ):\r\n        """\r\n        The target function for the separate game process. Do not call directly.\r\n        """\r\n        # The BotAI class is instantiated here, inside the new process.\r\n        # It is passed the queues for communication.\r\n        bot_instance = bot_class(action_queue=action_queue, obs_queue=obs_queue)\r\n        \r\n        # This is a blocking call that runs the main python-sc2 game loop.\r\n        run_game(\r\n            maps.get(map_name),\r\n            [\r\n                Bot(bot_race, bot_instance),\r\n                Computer(opponent_race, difficulty)\r\n            ],\r\n            realtime=False,\r\n        )\r\n\n'})})]})}function m(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(p,{...e})}):p(e)}},8453:(e,n,r)=>{r.d(n,{R:()=>a,x:()=>i});var t=r(6540);const s={},o=t.createContext(s);function a(e){const n=t.useContext(o);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),t.createElement(o.Provider,{value:n},e.children)}}}]);