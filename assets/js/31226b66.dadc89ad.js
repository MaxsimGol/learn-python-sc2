"use strict";(self.webpackChunkmy_framework_docs=self.webpackChunkmy_framework_docs||[]).push([[3023],{7388:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>a,default:()=>h,frontMatter:()=>r,metadata:()=>s,toc:()=>l});const s=JSON.parse('{"id":"Part 2 - Core Concepts/Chapter 5 - Issuing Commands - Actions/5.1 - The Core of Control","title":"5.1 - The Core of Control","description":"Every command your bot issues\u2014every attack, move, or build order\u2014is an action that must be sent to the StarCraft II game engine. The functions that handle this critical transmission are built into the BotAI class and its Unit objects.","source":"@site/docs/Part 2 - Core Concepts/Chapter 5 - Issuing Commands - Actions/5.1 - The Core of Control.md","sourceDirName":"Part 2 - Core Concepts/Chapter 5 - Issuing Commands - Actions","slug":"/Part 2 - Core Concepts/Chapter 5 - Issuing Commands - Actions/5.1 - The Core of Control","permalink":"/learn-python-sc2/docs/Part 2 - Core Concepts/Chapter 5 - Issuing Commands - Actions/5.1 - The Core of Control","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"4.4 - Managing Groups- The Units Collection","permalink":"/learn-python-sc2/docs/Part 2 - Core Concepts/Chapter 4 - Reading the Game State/4.4 - Managing Groups- The Units Collection"},"next":{"title":"5.2 - Basic Commands- Attack, Move, Stop","permalink":"/learn-python-sc2/docs/Part 2 - Core Concepts/Chapter 5 - Issuing Commands - Actions/5.2 - Basic Commands- Attack, Move, Stop"}}');var i=n(4848),o=n(8453);const r={},a=void 0,c={},l=[{value:"<strong>The Action Pipeline: From Intent to Execution</strong>",id:"the-action-pipeline-from-intent-to-execution",level:4},{value:"<strong>Individual vs. Batched Actions: A Performance Choice</strong>",id:"individual-vs-batched-actions-a-performance-choice",level:4},{value:"<strong>A Developer&#39;s Checklist for Issuing Commands</strong>",id:"a-developers-checklist-for-issuing-commands",level:4},{value:"<strong>Code Example: Simple vs. Batched Performance</strong>",id:"code-example-simple-vs-batched-performance",level:4}];function d(e){const t={code:"code",h4:"h4",hr:"hr",input:"input",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,o.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(t.p,{children:["Every command your bot issues\u2014every attack, move, or build order\u2014is an action that must be sent to the StarCraft II game engine. The functions that handle this critical transmission are built into the ",(0,i.jsx)(t.code,{children:"BotAI"})," class and its ",(0,i.jsx)(t.code,{children:"Unit"})," objects."]}),"\n",(0,i.jsxs)(t.p,{children:["While there is a low-level ",(0,i.jsx)(t.code,{children:"self.do()"})," function, you will almost always use the high-level, convenient command methods like ",(0,i.jsx)(t.code,{children:"unit.attack()"})," or ",(0,i.jsx)(t.code,{children:"self.build()"}),". Understanding the two primary ways to execute these commands\u2014individually or in a batch\u2014is essential for writing an efficient bot."]}),"\n",(0,i.jsx)(t.h4,{id:"the-action-pipeline-from-intent-to-execution",children:(0,i.jsx)(t.strong,{children:"The Action Pipeline: From Intent to Execution"})}),"\n",(0,i.jsx)(t.p,{children:"When you want a unit to perform an action, your command goes through a simple pipeline."}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"+-----------------------------------+   (Stage 1)   +----------------------+   (Stage 2)   +--------------------------+\r\n| Your Intent                       | ------------\x3e | Creates UnitCommand  | ------------\x3e | self.do_actions(actions) |\r\n| e.g., `my_marine.attack(target)`  |               |  (Behind the scenes) |               |  (Sends to SC2)          |\r\n+-----------------------------------+               +----------------------+               +--------------------------+\r\n        (High-Level Method)                        (Intermediate Data Object)                   (Batch-Sending Engine)\n"})}),"\n",(0,i.jsxs)(t.ol,{children:["\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"Stage 1: High-Level Helper Methods:"})," These are the readable methods on ",(0,i.jsx)(t.code,{children:"Unit"})," and ",(0,i.jsx)(t.code,{children:"BotAI"})," objects, like ",(0,i.jsx)(t.code,{children:"unit.attack()"}),", ",(0,i.jsx)(t.code,{children:"self.build()"}),", etc. When you call one, it creates a ",(0,i.jsx)(t.code,{children:"UnitCommand"})," data object that represents your intent."]}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsxs)(t.p,{children:[(0,i.jsxs)(t.strong,{children:["Stage 2: The ",(0,i.jsx)(t.code,{children:"do_actions"})," Engine:"]})," The ",(0,i.jsx)(t.code,{children:"await self.do_actions()"})," function takes a list of those ",(0,i.jsx)(t.code,{children:"UnitCommand"})," objects and sends them all to the game engine in a single, efficient batch for execution. Awaiting a single action like ",(0,i.jsx)(t.code,{children:"await unit.attack()"})," is effectively a shortcut for creating and sending a batch of one."]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:"This design gives you the best of both worlds: readable, high-level methods for creating actions and an efficient, low-level function for executing them in batches."}),"\n",(0,i.jsx)(t.hr,{}),"\n",(0,i.jsx)(t.h4,{id:"individual-vs-batched-actions-a-performance-choice",children:(0,i.jsx)(t.strong,{children:"Individual vs. Batched Actions: A Performance Choice"})}),"\n",(0,i.jsx)(t.p,{children:"You have two ways to execute actions. Your choice has significant performance implications, especially when commanding large armies."}),"\n",(0,i.jsxs)(t.table,{children:[(0,i.jsx)(t.thead,{children:(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.th,{style:{textAlign:"left"},children:"Method"}),(0,i.jsxs)(t.th,{style:{textAlign:"left"},children:[(0,i.jsx)(t.code,{children:"await unit.attack(...)"})," (in a loop)"]}),(0,i.jsx)(t.th,{style:{textAlign:"left"},children:(0,i.jsx)(t.code,{children:"await self.do_actions([...])"})})]})}),(0,i.jsxs)(t.tbody,{children:[(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{style:{textAlign:"left"},children:(0,i.jsx)(t.strong,{children:"How It Works"})}),(0,i.jsxs)(t.td,{style:{textAlign:"left"},children:["Each ",(0,i.jsx)(t.code,{children:"await"})," sends a command (or a micro-batch of one) to the game and waits for the game step to advance."]}),(0,i.jsx)(t.td,{style:{textAlign:"left"},children:"Collects many commands into a list and sends them all to the game in a single, efficient batch."})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{style:{textAlign:"left"},children:(0,i.jsx)(t.strong,{children:"Analogy"})}),(0,i.jsx)(t.td,{style:{textAlign:"left"},children:"Making a separate phone call for every single instruction."}),(0,i.jsx)(t.td,{style:{textAlign:"left"},children:"Sending one text message with a complete list of instructions."})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{style:{textAlign:"left"},children:(0,i.jsx)(t.strong,{children:"Pros"})}),(0,i.jsx)(t.td,{style:{textAlign:"left"},children:"Very simple and intuitive for single actions."}),(0,i.jsxs)(t.td,{style:{textAlign:"left"},children:[(0,i.jsx)(t.strong,{children:"Highly performant."})," Drastically reduces overhead when issuing many commands in one step."]})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{style:{textAlign:"left"},children:(0,i.jsx)(t.strong,{children:"Cons"})}),(0,i.jsxs)(t.td,{style:{textAlign:"left"},children:["Inefficient for large groups. Can significantly slow down your ",(0,i.jsx)(t.code,{children:"on_step"})," loop due to repeated ",(0,i.jsx)(t.code,{children:"await"})," overhead."]}),(0,i.jsx)(t.td,{style:{textAlign:"left"},children:"Requires slightly more code (creating a list and appending to it)."})]})]})]}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"Best Practice:"})," For any loop that issues commands to multiple units, ",(0,i.jsxs)(t.strong,{children:["always use the batched ",(0,i.jsx)(t.code,{children:"self.do_actions()"})," method."]})]}),"\n",(0,i.jsx)(t.hr,{}),"\n",(0,i.jsx)(t.h4,{id:"a-developers-checklist-for-issuing-commands",children:(0,i.jsx)(t.strong,{children:"A Developer's Checklist for Issuing Commands"})}),"\n",(0,i.jsxs)(t.ul,{className:"contains-task-list",children:["\n",(0,i.jsxs)(t.li,{className:"task-list-item",children:[(0,i.jsx)(t.input,{type:"checkbox",disabled:!0})," ",(0,i.jsx)(t.strong,{children:"1. Use High-Level Methods:"})," Always use the convenient methods like ",(0,i.jsx)(t.code,{children:"unit.attack()"})," or ",(0,i.jsx)(t.code,{children:"self.train()"})," to create your actions."]}),"\n",(0,i.jsxs)(t.li,{className:"task-list-item",children:[(0,i.jsx)(t.input,{type:"checkbox",disabled:!0})," ",(0,i.jsx)(t.strong,{children:"2. Single Action?"})," If you are only issuing one command, ",(0,i.jsx)(t.code,{children:"await"})," it directly: ",(0,i.jsx)(t.code,{children:"await self.build(...)"}),"."]}),"\n",(0,i.jsxs)(t.li,{className:"task-list-item",children:[(0,i.jsx)(t.input,{type:"checkbox",disabled:!0})," ",(0,i.jsx)(t.strong,{children:"3. Multiple Actions?"})," If you are looping through a ",(0,i.jsx)(t.code,{children:"Units"})," collection:","\n",(0,i.jsxs)(t.ul,{className:"contains-task-list",children:["\n",(0,i.jsxs)(t.li,{className:"task-list-item",children:[(0,i.jsx)(t.input,{type:"checkbox",disabled:!0})," ","Create an empty list: ",(0,i.jsx)(t.code,{children:"actions = []"}),"."]}),"\n",(0,i.jsxs)(t.li,{className:"task-list-item",children:[(0,i.jsx)(t.input,{type:"checkbox",disabled:!0})," ","In the loop, ",(0,i.jsx)(t.code,{children:"append"})," the command objects to the list ",(0,i.jsx)(t.strong,{children:"without"})," ",(0,i.jsx)(t.code,{children:"await"}),"."]}),"\n",(0,i.jsxs)(t.li,{className:"task-list-item",children:[(0,i.jsx)(t.input,{type:"checkbox",disabled:!0})," ","After the loop, ",(0,i.jsx)(t.code,{children:"await self.do_actions(actions)"}),"."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(t.hr,{}),"\n",(0,i.jsx)(t.h4,{id:"code-example-simple-vs-batched-performance",children:(0,i.jsx)(t.strong,{children:"Code Example: Simple vs. Batched Performance"})}),"\n",(0,i.jsx)(t.p,{children:"This bot demonstrates the two methods for commanding a group of idle Marines. You can comment out one block and run the other to see the difference. The batched method is the professional standard."}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-python",children:'# batch_action_bot.py\r\n\r\nfrom sc2 import maps\r\nfrom sc2.bot_ai import BotAI\r\nfrom sc2.data import Difficulty, Race\r\nfrom sc2.main import run_game\r\nfrom sc2.player import Bot, Computer\r\nfrom sc2.ids.unit_typeid import UnitTypeId\r\nfrom sc2.units import Units\r\n\r\nclass BatchActionBot(BotAI):\r\n    """Demonstrates the performance difference between individual and batched actions."""\r\n\r\n    async def on_step(self, iteration: int):\r\n        # We need a target for our marines to attack.\r\n        target = self.enemy_start_locations[0].towards(self.start_location, 15)\r\n        # Find all idle marines.\r\n        idle_marines: Units = self.units(UnitTypeId.MARINE).idle\r\n\r\n        if not idle_marines.exists:\r\n            # If no idle marines, just build more and do nothing else this step.\r\n            await self.train_reinforcements()\r\n            return\r\n\r\n        # --- Method 1: Individual Commands (Simple but Inefficient) ---\r\n        # Each \'await\' waits for the next game step.\r\n        # This is fine for 1-2 units, but very slow for 20+.\r\n        # for marine in idle_marines:\r\n        #     await marine.attack(target)\r\n\r\n        # --- Method 2: Batched Commands (The Professional Standard) ---\r\n        # This is far more efficient as it sends all commands in one go.\r\n        actions = []\r\n        for marine in idle_marines:\r\n            # Create the command object and add it to our list.\r\n            actions.append(marine.attack(target))\r\n        # Send all commands at once.\r\n        await self.do_actions(actions)\r\n\r\n\r\n    async def train_reinforcements(self):\r\n        """A simple method to build some prerequisite structures and train marines."""\r\n        if self.supply_left < 3 and self.already_pending(UnitTypeId.SUPPLYDEPOT) == 0:\r\n            if self.can_afford(UnitTypeId.SUPPLYDEPOT):\r\n                await self.build(UnitTypeId.SUPPLYDEPOT, near=self.start_location.towards(self.game_info.map_center, 5))\r\n        if self.structures(UnitTypeId.BARRACKS).amount < 2:\r\n            if self.can_afford(UnitTypeId.BARRACKS):\r\n                await self.build(UnitTypeId.BARRACKS, near=self.start_location.towards(self.game_info.map_center, 8))\r\n        if self.structures(UnitTypeId.BARRACKS).ready.idle.exists and self.can_afford(UnitTypeId.MARINE):\r\n            await self.train(UnitTypeId.MARINE)\r\n\r\n\r\nif __name__ == "__main__":\r\n    run_game(\r\n        maps.get("BlackburnAIE"),\r\n        [\r\n            Bot(Race.Terran, BatchActionBot()),\r\n            Computer(Race.Zerg, Difficulty.Easy)\r\n        ],\r\n        realtime=True,\r\n    )\n'})})]})}function h(e={}){const{wrapper:t}={...(0,o.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>r,x:()=>a});var s=n(6540);const i={},o=s.createContext(i);function r(e){const t=s.useContext(o);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),s.createElement(o.Provider,{value:t},e.children)}}}]);