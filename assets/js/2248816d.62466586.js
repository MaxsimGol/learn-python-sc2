"use strict";(self.webpackChunkmy_framework_docs=self.webpackChunkmy_framework_docs||[]).push([[92],{7254:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>o,default:()=>h,frontMatter:()=>a,metadata:()=>s,toc:()=>l});const s=JSON.parse('{"id":"Part 3 - Advanced Development/Chapter 7 - Performance and Debugging/7.2 - Common Pitfalls- Desyncs and Stale Data","title":"7.2 - Common Pitfalls- Desyncs and Stale Data","description":"Beyond simple syntax errors, bot development has its own class of insidious bugs. Two of the most common and difficult to diagnose are desyncs and errors caused by stale data. Understanding these pitfalls is essential for building a stable and reliable bot.","source":"@site/docs/Part 3 - Advanced Development/Chapter 7 - Performance and Debugging/7.2 - Common Pitfalls- Desyncs and Stale Data.md","sourceDirName":"Part 3 - Advanced Development/Chapter 7 - Performance and Debugging","slug":"/Part 3 - Advanced Development/Chapter 7 - Performance and Debugging/7.2 - Common Pitfalls- Desyncs and Stale Data","permalink":"/learn-python-sc2/docs/Part 3 - Advanced Development/Chapter 7 - Performance and Debugging/7.2 - Common Pitfalls- Desyncs and Stale Data","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"7.1 - Writing Efficient Code - Managing APM","permalink":"/learn-python-sc2/docs/Part 3 - Advanced Development/Chapter 7 - Performance and Debugging/7.1 - Writing Efficient Code - Managing APM"},"next":{"title":"7.3 - How to Debug and Analyze Replays","permalink":"/learn-python-sc2/docs/Part 3 - Advanced Development/Chapter 7 - Performance and Debugging/7.3 - How to Debug and Analyze Replays"}}');var r=n(4848),i=n(8453);const a={},o=void 0,c={},l=[{value:"<strong>Pitfall 1: The Desync Bug</strong>",id:"pitfall-1-the-desync-bug",level:4},{value:"<strong>Pitfall 2: Stale Data</strong>",id:"pitfall-2-stale-data",level:4},{value:"<strong>A Developer&#39;s Checklist for Data Persistence</strong>",id:"a-developers-checklist-for-data-persistence",level:4},{value:"<strong>Code Example: The Scout Tracker</strong>",id:"code-example-the-scout-tracker",level:4}];function d(e){const t={code:"code",em:"em",h4:"h4",hr:"hr",input:"input",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(t.p,{children:["Beyond simple syntax errors, bot development has its own class of insidious bugs. Two of the most common and difficult to diagnose are ",(0,r.jsx)(t.strong,{children:"desyncs"})," and errors caused by ",(0,r.jsx)(t.strong,{children:"stale data"}),". Understanding these pitfalls is essential for building a stable and reliable bot."]}),"\n",(0,r.jsx)(t.hr,{}),"\n",(0,r.jsx)(t.h4,{id:"pitfall-1-the-desync-bug",children:(0,r.jsx)(t.strong,{children:"Pitfall 1: The Desync Bug"})}),"\n",(0,r.jsx)(t.p,{children:'A "desync" (desynchronization) is a critical failure where your bot\'s perception of the game world no longer matches the reality of the game engine. Your bot is effectively "hallucinating"\u2014seeing units that aren\'t there or missing units that are.'}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.strong,{children:"The Anatomy of a Desync:"})}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{children:"+-----------------+                     +----------------+\r\n|  Your Bot's     |   (Commands are     |                |\r\n|  Internal State |     too frequent    |   SC2 Game     |\r\n|  (e.g., sees 10 |     or complex)     |     Engine     |\r\n|   marines)      |  -----------------\x3e |  (e.g., only   |\r\n+-----------------+                     |  has 5 marines)|\r\n        |                               +----------------+\r\n        | (State Mismatch)\r\n        v\r\n    CRITICAL FAILURE\r\n(Bot issues commands for\r\n units that don't exist)\n"})}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Primary Cause:"})," Sending an overwhelming number of commands to the game engine. This is almost always a symptom of inefficient code that spams redundant commands (see Chapter 7.1)."]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"The Danger Zone:"})," APM consistently in the tens of thousands is a major warning sign."]}),"\n"]}),"\n",(0,r.jsxs)(t.table,{children:[(0,r.jsx)(t.thead,{children:(0,r.jsx)(t.tr,{children:(0,r.jsx)(t.th,{style:{textAlign:"left"},children:"How to Avoid Desyncs"})})}),(0,r.jsxs)(t.tbody,{children:[(0,r.jsx)(t.tr,{children:(0,r.jsxs)(t.td,{style:{textAlign:"left"},children:[(0,r.jsx)(t.strong,{children:"1. Follow Efficiency Principles:"})," Write smart, non-redundant command logic."]})}),(0,r.jsx)(t.tr,{children:(0,r.jsxs)(t.td,{style:{textAlign:"left"},children:[(0,r.jsx)(t.strong,{children:"2. Command Only What's Needed:"})," Only issue commands to units whose state needs to change (e.g., ",(0,r.jsx)(t.code,{children:".idle"})," units)."]})}),(0,r.jsx)(t.tr,{children:(0,r.jsxs)(t.td,{style:{textAlign:"left"},children:[(0,r.jsx)(t.strong,{children:"3. Trust the Library's Batching:"})," Simply call action methods (e.g., ",(0,r.jsx)(t.code,{children:"my_unit.attack(target)"}),"). The library automatically collects all commands within a step and sends them as one batch."]})}),(0,r.jsx)(t.tr,{children:(0,r.jsxs)(t.td,{style:{textAlign:"left"},children:[(0,r.jsx)(t.strong,{children:"4. Monitor Your APM:"})," Use ",(0,r.jsx)(t.code,{children:"self.state.score.apm"})," to check your bot's APM. If it's abnormally high, it's a bug."]})})]})]}),"\n",(0,r.jsx)(t.hr,{}),"\n",(0,r.jsx)(t.h4,{id:"pitfall-2-stale-data",children:(0,r.jsx)(t.strong,{children:"Pitfall 2: Stale Data"})}),"\n",(0,r.jsxs)(t.p,{children:['A "stale data" bug occurs when your bot makes a decision based on outdated information. The #1 cause of this is incorrectly storing a ',(0,r.jsx)(t.code,{children:"Unit"})," object in a ",(0,r.jsx)(t.code,{children:"self"})," variable between game steps."]}),"\n",(0,r.jsxs)(t.p,{children:[(0,r.jsxs)(t.strong,{children:["The Problem: The ",(0,r.jsx)(t.code,{children:"Unit"})," Object is a Temporary Snapshot"]}),"\r\nThe ",(0,r.jsx)(t.code,{children:"Unit"})," objects you receive in ",(0,r.jsx)(t.code,{children:"self.units"})," on each ",(0,r.jsx)(t.code,{children:"on_step"})," are ",(0,r.jsx)(t.strong,{children:"snapshots in time"}),". They are valid ",(0,r.jsx)(t.em,{children:"only for that single game step"}),". On the next step, the library creates a fresh set of ",(0,r.jsx)(t.code,{children:"Unit"})," objects with updated data. A ",(0,r.jsx)(t.code,{children:"Unit"}),' object from a previous step is now "stale"\u2014its position, health, and other data are wrong.']}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{children:"          on_step(iteration=100)\r\n+------------------------------------+\r\n|  Unit A (tag=1, health=50, pos=X)  | <-- You get this fresh object.\r\n+------------------------------------+\r\n| self.my_favorite_unit = Unit A     | <-- DANGER: You store the object itself.\r\n`------------------------------------`\r\n                  |\r\n                  v\r\n          on_step(iteration=101)\r\n+------------------------------------+\r\n|  Unit A (tag=1, health=40, pos=Y)  | <-- The library gets a new, updated object.\r\n+------------------------------------+\r\n| self.my_favorite_unit.health       | <-- This still returns 50! It's stale.\r\n`------------------------------------`\n"})}),"\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.strong,{children:"The Solution: Store Tags, Not Objects"}),"\r\nA unit's ",(0,r.jsx)(t.code,{children:"tag"}),' is a unique integer that is permanent for the entire match. It\'s the "serial number" for that unit.']}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.strong,{children:"The Golden Rule:"})}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"DO NOT"})," store ",(0,r.jsx)(t.code,{children:"Unit"})," or ",(0,r.jsx)(t.code,{children:"Units"})," objects in ",(0,r.jsx)(t.code,{children:"self"})," variables."]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"DO"})," store a unit's ",(0,r.jsx)(t.code,{children:".tag"})," if you need to track it over time."]}),"\n"]}),"\n",(0,r.jsx)(t.hr,{}),"\n",(0,r.jsx)(t.h4,{id:"a-developers-checklist-for-data-persistence",children:(0,r.jsx)(t.strong,{children:"A Developer's Checklist for Data Persistence"})}),"\n",(0,r.jsxs)(t.ul,{className:"contains-task-list",children:["\n",(0,r.jsxs)(t.li,{className:"task-list-item",children:[(0,r.jsx)(t.input,{type:"checkbox",disabled:!0})," ",(0,r.jsx)(t.strong,{children:"Do I need to track a specific unit across multiple steps?"})," (e.g., a scout, a specific spellcaster)."]}),"\n",(0,r.jsxs)(t.li,{className:"task-list-item",children:[(0,r.jsx)(t.input,{type:"checkbox",disabled:!0})," ",(0,r.jsx)(t.strong,{children:"If yes, get its tag:"})," ",(0,r.jsx)(t.code,{children:"self.scout_tag = my_scout.tag"}),"."]}),"\n",(0,r.jsxs)(t.li,{className:"task-list-item",children:[(0,r.jsx)(t.input,{type:"checkbox",disabled:!0})," ",(0,r.jsx)(t.strong,{children:"In later steps, retrieve the fresh unit object using the tag:"})," ",(0,r.jsx)(t.code,{children:"current_scout = self.units.find_by_tag(self.scout_tag)"}),"."]}),"\n",(0,r.jsxs)(t.li,{className:"task-list-item",children:[(0,r.jsx)(t.input,{type:"checkbox",disabled:!0})," ",(0,r.jsx)(t.strong,{children:"Always handle the case where the unit might be dead:"})," ",(0,r.jsx)(t.code,{children:"if current_scout is None:"}),"."]}),"\n"]}),"\n",(0,r.jsx)(t.hr,{}),"\n",(0,r.jsx)(t.h4,{id:"code-example-the-scout-tracker",children:(0,r.jsx)(t.strong,{children:"Code Example: The Scout Tracker"})}),"\n",(0,r.jsxs)(t.p,{children:["This bot demonstrates the correct, professional way to track a specific unit. It designates a scout, stores its ",(0,r.jsx)(t.code,{children:"tag"}),", and then correctly retrieves the fresh ",(0,r.jsx)(t.code,{children:"Unit"})," object on each step to check its status."]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-python",children:'# scout_tracker_bot.py\r\nfrom typing import Optional\r\n\r\nfrom sc2 import maps\r\nfrom sc2.bot_ai import BotAI\r\nfrom sc2.data import Difficulty, Race\r\nfrom sc2.main import run_game\r\nfrom sc2.player import Bot, Computer\r\nfrom sc2.unit import Unit\r\n\r\n\r\nclass ScoutTrackerBot(BotAI):\r\n    """Demonstrates the correct way to track a unit using its tag to avoid stale data."""\r\n\r\n    def __init__(self):\r\n        super().__init__()\r\n        # This will hold the scout\'s permanent ID, not a temporary object.\r\n        self.scout_tag: Optional[int] = None\r\n\r\n    async def on_step(self, iteration: int):\r\n        # 1. Designate the scout at the start of the game.\r\n        if iteration == 0:\r\n            # Select a worker to be our scout.\r\n            initial_scout_unit = self.workers.random\r\n            if initial_scout_unit:\r\n                # CORRECT: Store the integer tag.\r\n                self.scout_tag = initial_scout_unit.tag\r\n                print(f"Designated worker with tag {self.scout_tag} as the scout.")\r\n                # Send the scout to the enemy base.\r\n                initial_scout_unit.attack(self.enemy_start_locations[0])\r\n\r\n        # 2. Track the scout on every subsequent step.\r\n        if self.scout_tag is not None:\r\n            # CORRECT: Retrieve the fresh, up-to-date Unit object using the stored tag.\r\n            # This returns the unit object if it\'s visible, otherwise None.\r\n            current_scout: Optional[Unit] = self.units.find_by_tag(self.scout_tag)\r\n\r\n            if current_scout:\r\n                # The scout is alive and visible. We can safely use its current data.\r\n                if iteration % 112 == 0:  # Throttle the log message.\r\n                    print(f"Scout {self.scout_tag} is alive at {current_scout.position.rounded}.")\r\n            else:\r\n                # The scout is dead or has gone out of our vision.\r\n                print(f"Scout {self.scout_tag} has been lost. Resetting.")\r\n                # Reset the tag so we can assign a new scout if needed.\r\n                self.scout_tag = None\r\n\r\n\r\nif __name__ == "__main__":\r\n    run_game(\r\n        maps.get("GresvanAIE"),\r\n        [\r\n            Bot(Race.Terran, ScoutTrackerBot()),\r\n            Computer(Race.Zerg, Difficulty.Easy)\r\n        ],\r\n        realtime=True,\r\n    )\n'})})]})}function h(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>a,x:()=>o});var s=n(6540);const r={},i=s.createContext(r);function a(e){const t=s.useContext(i);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),s.createElement(i.Provider,{value:t},e.children)}}}]);