"use strict";(self.webpackChunkmy_framework_docs=self.webpackChunkmy_framework_docs||[]).push([[2620],{4642:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>r,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"Part 5 - Reinforcement Learning/Advanced RL and Next Steps/Chapter 8 - Advanced Implementation - DRL-RM/8.1 - Concept - A More Generalized Agent","title":"8.1 - Concept - A More Generalized Agent","description":"The agents developed in Part 5, while effective at their specific tasks, are fundamentally limited by their fixed-size observation and action spaces. They are brittle; the MicroBot has no capacity to handle a second Zergling, and the MacroBot has no concept of building a Barracks.","source":"@site/docs/Part 5 - Reinforcement Learning/2 - Advanced RL and Next Steps/02-Chapter 8 - Advanced Implementation - DRL-RM/8.1 - Concept - A More Generalized Agent.md","sourceDirName":"Part 5 - Reinforcement Learning/2 - Advanced RL and Next Steps/02-Chapter 8 - Advanced Implementation - DRL-RM","slug":"/Part 5 - Reinforcement Learning/Advanced RL and Next Steps/Chapter 8 - Advanced Implementation - DRL-RM/8.1 - Concept - A More Generalized Agent","permalink":"/learn-python-sc2/docs/Part 5 - Reinforcement Learning/Advanced RL and Next Steps/Chapter 8 - Advanced Implementation - DRL-RM/8.1 - Concept - A More Generalized Agent","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"7.2 - What to Look For in Training Graphs","permalink":"/learn-python-sc2/docs/Part 5 - Reinforcement Learning/Advanced RL and Next Steps/Chapter 7 - Visualizing and Evaluating Training/7.2 - What to Look For in Training Graphs"},"next":{"title":"8.2 - Code - A Simplified DRL-RM Implementation","permalink":"/learn-python-sc2/docs/Part 5 - Reinforcement Learning/Advanced RL and Next Steps/Chapter 8 - Advanced Implementation - DRL-RM/8.2 - Code - A Simplified DRL-RM Implementation"}}');var s=n(4848),a=n(8453);const r={},o=void 0,l={},c=[{value:"<strong>The Core Architectural Shift</strong>",id:"the-core-architectural-shift",level:4},{value:"<strong>The Decomposed Action Space</strong>",id:"the-decomposed-action-space",level:4},{value:"<strong>The Role of a Relational Module</strong>",id:"the-role-of-a-relational-module",level:4},{value:"<strong>Our Implementation Goal</strong>",id:"our-implementation-goal",level:4}];function d(e){const t={code:"code",h4:"h4",input:"input",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,a.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(t.p,{children:["The agents developed in Part 5, while effective at their specific tasks, are fundamentally limited by their ",(0,s.jsx)(t.strong,{children:"fixed-size observation and action spaces"}),". They are brittle; the ",(0,s.jsx)(t.code,{children:"MicroBot"})," has no capacity to handle a second Zergling, and the ",(0,s.jsx)(t.code,{children:"MacroBot"})," has no concept of building a Barracks."]}),"\n",(0,s.jsxs)(t.p,{children:["To progress toward an agent capable of playing a full game of StarCraft II, we must adopt an architecture that can handle a ",(0,s.jsx)(t.strong,{children:"variable number of entities and actions"}),". This section introduces the concepts behind a more generalized agent, inspired by advanced architectures like DRL-RM."]}),"\n",(0,s.jsx)(t.h4,{id:"the-core-architectural-shift",children:(0,s.jsx)(t.strong,{children:"The Core Architectural Shift"})}),"\n",(0,s.jsx)(t.p,{children:"Our previous approach is insufficient for generalized gameplay. The new approach must be able to process a dynamic list of units and decompose complex decisions."}),"\n",(0,s.jsxs)(t.table,{children:[(0,s.jsx)(t.thead,{children:(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.th,{style:{textAlign:"left"},children:"Aspect"}),(0,s.jsxs)(t.th,{style:{textAlign:"left"},children:[(0,s.jsx)(t.code,{children:"Fixed Vector"})," Architecture (Previous Bots)"]}),(0,s.jsxs)(t.th,{style:{textAlign:"left"},children:[(0,s.jsx)(t.code,{children:"Entity-Based"})," Architecture (Generalized Bot)"]})]})}),(0,s.jsxs)(t.tbody,{children:[(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{style:{textAlign:"left"},children:(0,s.jsx)(t.strong,{children:"Problem"})}),(0,s.jsxs)(t.td,{style:{textAlign:"left"},children:["The observation vector has a fixed size and meaning (e.g., ",(0,s.jsx)(t.code,{children:"[marine_hp, zergling_hp]"}),"). This breaks if the number or type of units changes."]}),(0,s.jsx)(t.td,{style:{textAlign:"left"},children:"How can the agent perceive and act upon a dynamic number of different units?"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{style:{textAlign:"left"},children:(0,s.jsx)(t.strong,{children:"Solution"})}),(0,s.jsxs)(t.td,{style:{textAlign:"left"},children:[(0,s.jsx)(t.strong,{children:'"Flattened Features."'})," A single vector representing a highly specific, pre-defined scenario."]}),(0,s.jsxs)(t.td,{style:{textAlign:"left"},children:[(0,s.jsx)(t.strong,{children:'"List of Entities."'})," The observation is a list of feature vectors, where each vector represents a single unit. This list can grow or shrink."]})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{style:{textAlign:"left"},children:(0,s.jsx)(t.strong,{children:"Limitation"})}),(0,s.jsx)(t.td,{style:{textAlign:"left"},children:"Cannot scale beyond its pre-defined scenario."}),(0,s.jsx)(t.td,{style:{textAlign:"left"},children:"Requires a more complex policy network to process variable-length, unordered data."})]})]})]}),"\n",(0,s.jsx)(t.h4,{id:"the-decomposed-action-space",children:(0,s.jsx)(t.strong,{children:"The Decomposed Action Space"})}),"\n",(0,s.jsxs)(t.p,{children:['Instead of having a single action space with one choice (e.g., "Kite"), a generalized agent must make a sequence of related sub-decisions. This is often called a ',(0,s.jsx)(t.strong,{children:"decomposed"})," or ",(0,s.jsx)(t.strong,{children:"auto-regressive"})," action space. The agent must learn a policy to answer a series of questions:"]}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.strong,{children:'The "Who -> What -> Whom" Decision Process:'})}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{children:"+--------------------------+     +--------------------------+     +--------------------------+\r\n|       Step 1:            |     |       Step 2:            |     |       Step 3:            |\r\n|       SELECT ACTOR       |----\x3e|       SELECT ABILITY     |----\x3e|       SELECT TARGET      |\r\n+--------------------------+     +--------------------------+     +--------------------------+\r\n| (Which of my units       |     | (What action should      |     | (Which enemy unit or point|\r\n|  should act?)            |     |  the selected unit take?)|     |  should be the target?)  |\r\n+--------------------------+     +--------------------------+     +--------------------------+\r\n  Output: index of a friendly unit   Output: index of an ability (Move, Attack)  Output: index of a target unit\n"})}),"\n",(0,s.jsxs)(t.p,{children:['The final command is an assembly of these three sub-decisions: "Unit ',(0,s.jsx)(t.code,{children:"i"})," uses ability ",(0,s.jsx)(t.code,{children:"j"})," on target ",(0,s.jsx)(t.code,{children:"k"}),'."']}),"\n",(0,s.jsx)(t.h4,{id:"the-role-of-a-relational-module",children:(0,s.jsx)(t.strong,{children:"The Role of a Relational Module"})}),"\n",(0,s.jsxs)(t.p,{children:["A key component of advanced architectures like DRL-RM is a ",(0,s.jsx)(t.strong,{children:"relational module"})," (often an ",(0,s.jsx)(t.strong,{children:"attention mechanism"})," or ",(0,s.jsx)(t.strong,{children:"graph neural network"}),")."]}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Purpose:"})," To process the unordered list of unit features and learn the critical relationships between them."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Function:"}),' It allows the agent to answer questions like, "Which of my units is currently being attacked?" or "Which enemy unit is the most isolated and vulnerable?" This is essential context for making intelligent decisions in the "Who -> What -> Whom" process.']}),"\n"]}),"\n",(0,s.jsx)(t.h4,{id:"our-implementation-goal",children:(0,s.jsx)(t.strong,{children:"Our Implementation Goal"})}),"\n",(0,s.jsx)(t.p,{children:"Building a full, research-grade DRL-RM agent with an attention module is a complex Ph.D.-level project. Our goal in this section is more modest and practical:"}),"\n",(0,s.jsxs)(t.ul,{className:"contains-task-list",children:["\n",(0,s.jsxs)(t.li,{className:"task-list-item",children:[(0,s.jsx)(t.input,{type:"checkbox",checked:!0,disabled:!0})," ","To implement a ",(0,s.jsx)(t.strong,{children:"simplified version"})," of this architecture."]}),"\n",(0,s.jsxs)(t.li,{className:"task-list-item",children:[(0,s.jsx)(t.input,{type:"checkbox",checked:!0,disabled:!0})," ","To create an environment where the observation is a ",(0,s.jsx)(t.strong,{children:"list of unit feature vectors"}),"."]}),"\n",(0,s.jsxs)(t.li,{className:"task-list-item",children:[(0,s.jsx)(t.input,{type:"checkbox",checked:!0,disabled:!0})," ","To create a ",(0,s.jsx)(t.strong,{children:"decomposed action space"})," that selects an actor, ability, and target."]}),"\n",(0,s.jsxs)(t.li,{className:"task-list-item",children:[(0,s.jsx)(t.input,{type:"checkbox",checked:!0,disabled:!0})," ","To use a standard Multi-Layer Perceptron (MLP) as a stand-in for a more complex relational module."]}),"\n"]}),"\n",(0,s.jsx)(t.p,{children:"This will provide a foundational, working example of how to structure a more generalized agent, paving the way for more advanced implementations."})]})}function h(e={}){const{wrapper:t}={...(0,a.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>r,x:()=>o});var i=n(6540);const s={},a=i.createContext(s);function r(e){const t=i.useContext(a);return i.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),i.createElement(a.Provider,{value:t},e.children)}}}]);