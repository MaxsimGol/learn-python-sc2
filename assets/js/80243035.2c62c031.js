"use strict";(self.webpackChunkmy_framework_docs=self.webpackChunkmy_framework_docs||[]).push([[2572],{2140:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>i,default:()=>h,frontMatter:()=>o,metadata:()=>s,toc:()=>d});const s=JSON.parse('{"id":"Part 3 - Advanced Development/Chapter 7 - Performance and Debugging/7.4 - Saving Data Between Matches","title":"7.4 - Saving Data Between Matches","description":"For a bot to learn, adapt, and improve over time, it must have a memory. It needs a way to store information from one match and retrieve it in the next. This capability, known as persistence, is the foundation of any learning AI.","source":"@site/docs/Part 3 - Advanced Development/Chapter 7 - Performance and Debugging/7.4 - Saving Data Between Matches.md","sourceDirName":"Part 3 - Advanced Development/Chapter 7 - Performance and Debugging","slug":"/Part 3 - Advanced Development/Chapter 7 - Performance and Debugging/7.4 - Saving Data Between Matches","permalink":"/learn-python-sc2/docs/Part 3 - Advanced Development/Chapter 7 - Performance and Debugging/7.4 - Saving Data Between Matches","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"7.3 - How to Debug and Analyze Replays","permalink":"/learn-python-sc2/docs/Part 3 - Advanced Development/Chapter 7 - Performance and Debugging/7.3 - How to Debug and Analyze Replays"},"next":{"title":"8.1 - What Your Bot Sees That a Human Can\'t - API Advantages","permalink":"/learn-python-sc2/docs/Part 4 - The Wider World/Chapter 8 - Bot Vision - Advantages and Limitations/8.1 - What Your Bot Sees That a Human Can\'t - API Advantages"}}');var r=n(4848),a=n(8453);const o={},i=void 0,l={},d=[{value:"<strong>The Persistence Lifecycle: Read, Update, Write</strong>",id:"the-persistence-lifecycle-read-update-write",level:4},{value:"<strong>Choosing Your Data Format: <code>json</code> vs. <code>pickle</code></strong>",id:"choosing-your-data-format-json-vs-pickle",level:4},{value:"<strong>A Developer&#39;s Checklist for Persistence</strong>",id:"a-developers-checklist-for-persistence",level:4},{value:"<strong>Code Example: The &quot;Adaptive&quot; Bot with an Encapsulated Knowledge Base</strong>",id:"code-example-the-adaptive-bot-with-an-encapsulated-knowledge-base",level:4}];function c(e){const t={code:"code",h4:"h4",hr:"hr",input:"input",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,a.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(t.p,{children:["For a bot to learn, adapt, and improve over time, it must have a memory. It needs a way to store information from one match and retrieve it in the next. This capability, known as ",(0,r.jsx)(t.strong,{children:"persistence"}),", is the foundation of any learning AI."]}),"\n",(0,r.jsxs)(t.p,{children:["While ",(0,r.jsx)(t.code,{children:"python-sc2"})," does not provide a built-in database, it fully supports standard Python file operations, allowing you to easily read and write data to your local disk."]}),"\n",(0,r.jsx)(t.h4,{id:"the-persistence-lifecycle-read-update-write",children:(0,r.jsx)(t.strong,{children:"The Persistence Lifecycle: Read, Update, Write"})}),"\n",(0,r.jsx)(t.p,{children:"The process of managing persistent data follows a simple, three-stage lifecycle that mirrors your bot's own."}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{children:"+--------------------------+\r\n|  1. Read on Start        | <-- In on_start(), load data from a file\r\n|  (Load Knowledge)        |     into a `self` variable.\r\n+--------------------------+\r\n           |\r\n           v\r\n+--------------------------+\r\n|  2. Update in `on_step`  | <-- As the game progresses, modify the\r\n|  (Gain Experience)       |     data in the `self` variable.\r\n+--------------------------+\r\n           |\r\n           v\r\n+--------------------------+\r\n|  3. Write on End         | <-- In on_end(), save the updated `self`\r\n|  (Record Knowledge)      |     variable back to the file.\r\n+--------------------------+\n"})}),"\n",(0,r.jsx)(t.p,{children:"By following this pattern, your bot creates a feedback loop, where the outcome of each game informs its strategy for the next."}),"\n",(0,r.jsx)(t.hr,{}),"\n",(0,r.jsx)(t.h4,{id:"choosing-your-data-format-json-vs-pickle",children:(0,r.jsxs)(t.strong,{children:["Choosing Your Data Format: ",(0,r.jsx)(t.code,{children:"json"})," vs. ",(0,r.jsx)(t.code,{children:"pickle"})]})}),"\n",(0,r.jsx)(t.p,{children:"You have two primary choices for how to format your data on disk. Your choice depends on the complexity of the data you need to store."}),"\n",(0,r.jsxs)(t.table,{children:[(0,r.jsx)(t.thead,{children:(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.th,{style:{textAlign:"left"},children:"Aspect"}),(0,r.jsxs)(t.th,{style:{textAlign:"left"},children:[(0,r.jsx)(t.code,{children:"json"})," (JavaScript Object Notation)"]}),(0,r.jsxs)(t.th,{style:{textAlign:"left"},children:[(0,r.jsx)(t.code,{children:"pickle"})," (Python Specific)"]})]})}),(0,r.jsxs)(t.tbody,{children:[(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{style:{textAlign:"left"},children:(0,r.jsx)(t.strong,{children:"Data Format"})}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:"Human-readable text."}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:"Binary, not human-readable."})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{style:{textAlign:"left"},children:(0,r.jsx)(t.strong,{children:"Use Case"})}),(0,r.jsxs)(t.td,{style:{textAlign:"left"},children:[(0,r.jsx)(t.strong,{children:"Recommended for most bots."})," Ideal for simple, structured data like dictionaries, lists, and numbers."]}),(0,r.jsxs)(t.td,{style:{textAlign:"left"},children:["For storing complex, custom Python objects or class instances that ",(0,r.jsx)(t.code,{children:"json"})," cannot handle."]})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{style:{textAlign:"left"},children:(0,r.jsx)(t.strong,{children:"Pros"})}),(0,r.jsxs)(t.td,{style:{textAlign:"left"},children:["- Easy to open and debug by hand.",(0,r.jsx)("br",{}),"- Language-agnostic."]}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:"- Can serialize almost any Python object."})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{style:{textAlign:"left"},children:(0,r.jsx)(t.strong,{children:"Cons"})}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:"- Limited to simple data types."}),(0,r.jsxs)(t.td,{style:{textAlign:"left"},children:["- Can be a security risk if loading files from an untrusted source.",(0,r.jsx)("br",{}),"- Tied to a specific Python version."]})]})]})]}),"\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.strong,{children:"The Professional Recommendation:"})," Start with ",(0,r.jsx)(t.code,{children:"json"}),". Its readability makes debugging far easier. Only move to ",(0,r.jsx)(t.code,{children:"pickle"})," if you have a specific, complex object that ",(0,r.jsx)(t.code,{children:"json"})," cannot represent."]}),"\n",(0,r.jsx)(t.hr,{}),"\n",(0,r.jsx)(t.h4,{id:"a-developers-checklist-for-persistence",children:(0,r.jsx)(t.strong,{children:"A Developer's Checklist for Persistence"})}),"\n",(0,r.jsxs)(t.ul,{className:"contains-task-list",children:["\n",(0,r.jsxs)(t.li,{className:"task-list-item",children:[(0,r.jsx)(t.input,{type:"checkbox",disabled:!0})," ",(0,r.jsx)(t.strong,{children:"1. Define Your Data Structure:"})," What information do I need to save? (e.g., a dictionary of strategies with win/loss counts)."]}),"\n",(0,r.jsxs)(t.li,{className:"task-list-item",children:[(0,r.jsx)(t.input,{type:"checkbox",disabled:!0})," ",(0,r.jsx)(t.strong,{children:"2. Encapsulate File Logic:"})," Create a helper class or functions to handle reading and writing. This keeps your main bot class clean."]}),"\n",(0,r.jsxs)(t.li,{className:"task-list-item",children:[(0,r.jsx)(t.input,{type:"checkbox",disabled:!0})," ",(0,r.jsxs)(t.strong,{children:["3. Implement the ",(0,r.jsx)(t.code,{children:"on_start"})," Hook:"]})," Load the data from the file into a ",(0,r.jsx)(t.code,{children:"self"})," variable. Handle the case where the file doesn't exist yet."]}),"\n",(0,r.jsxs)(t.li,{className:"task-list-item",children:[(0,r.jsx)(t.input,{type:"checkbox",disabled:!0})," ",(0,r.jsxs)(t.strong,{children:["4. Implement the ",(0,r.jsx)(t.code,{children:"on_end"})," Hook:"]})," Save the updated ",(0,r.jsx)(t.code,{children:"self"})," variable back to the file."]}),"\n"]}),"\n",(0,r.jsx)(t.hr,{}),"\n",(0,r.jsx)(t.h4,{id:"code-example-the-adaptive-bot-with-an-encapsulated-knowledge-base",children:(0,r.jsx)(t.strong,{children:'Code Example: The "Adaptive" Bot with an Encapsulated Knowledge Base'})}),"\n",(0,r.jsxs)(t.p,{children:["This bot demonstrates a professional approach to persistence. It uses a dedicated ",(0,r.jsx)(t.code,{children:"KnowledgeBase"})," class to manage all file I/O for its ",(0,r.jsx)(t.code,{children:"data.json"})," file. The bot uses this knowledge to choose the strategy with the best historical win rate, and updates the file with the result of each match."]}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.strong,{children:"To see this bot learn, you must run the script multiple times."})}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-python",children:'# adaptive_bot.py\r\n\r\nimport json\r\nfrom pathlib import Path\r\nfrom sc2 import maps\r\nfrom sc2.bot_ai import BotAI\r\nfrom sc2.data import Difficulty, Race, Result\r\nfrom sc2.main import run_game\r\nfrom sc2.player import Bot, Computer\r\nfrom typing import Dict\r\n\r\n# A dedicated class to handle all data persistence logic.\r\nclass KnowledgeBase:\r\n    def __init__(self, file_path: Path):\r\n        self.file_path = file_path\r\n        # Define the default structure of our knowledge base.\r\n        self.data: Dict[str, Dict[str, int]] = {\r\n            "aggressive": {"wins": 0, "losses": 0},\r\n            "defensive": {"wins": 0, "losses": 0},\r\n        }\r\n\r\n    def load(self):\r\n        """Loads data from the file, handling potential errors."""\r\n        try:\r\n            # Check if the file exists and is not empty.\r\n            if self.file_path.is_file() and self.file_path.stat().st_size > 0:\r\n                with open(self.file_path, "r") as f:\r\n                    self.data = json.load(f)\r\n                print(f"Knowledge loaded from {self.file_path}")\r\n            else:\r\n                print("No knowledge file found or file is empty. Starting fresh.")\r\n        except json.JSONDecodeError:\r\n            # Handle cases where the file is corrupted or not valid JSON.\r\n            print(f"Error decoding JSON from {self.file_path}. Starting with fresh knowledge.")\r\n        except Exception as e:\r\n            # Handle other potential file reading errors.\r\n            print(f"An unexpected error occurred while loading knowledge: {e}. Starting fresh.")\r\n\r\n    def save(self):\r\n        """Saves the current data to the file."""\r\n        try:\r\n            with open(self.file_path, "w") as f:\r\n                json.dump(self.data, f, indent=4)\r\n            print(f"Knowledge saved to {self.file_path}")\r\n        except Exception as e:\r\n            print(f"An unexpected error occurred while saving knowledge: {e}.")\r\n\r\n\r\n    def update_result(self, strategy: str, result: Result):\r\n        """Updates the win/loss count for a given strategy."""\r\n        if result == Result.Victory:\r\n            self.data[strategy]["wins"] += 1\r\n        else:\r\n            self.data[strategy]["losses"] += 1\r\n\r\n    def choose_strategy(self) -> str:\r\n        """Chooses the strategy with the best historical win rate."""\r\n        agg_wins = self.data["aggressive"]["wins"]\r\n        agg_total = sum(self.data["aggressive"].values()) or 1\r\n        def_wins = self.data["defensive"]["wins"]\r\n        def_total = sum(self.data["defensive"].values()) or 1\r\n\r\n        return "aggressive" if (agg_wins / agg_total) >= (def_wins / def_total) else "defensive"\r\n\r\n\r\n# The main bot class now uses the KnowledgeBase.\r\nclass AdaptiveBot(BotAI):\r\n    def __init__(self):\r\n        super().__init__()\r\n        # Define a path for the data file relative to this script\'s location.\r\n        # This makes the bot\'s data portable and independent of the launch directory.\r\n        knowledge_path = Path(__file__).parent / "bot_data.json"\r\n        self.knowledge = KnowledgeBase(knowledge_path)\r\n        self.current_strategy = None\r\n\r\n    async def on_start(self):\r\n        """Load knowledge and choose a strategy for this match."""\r\n        self.knowledge.load()\r\n        self.current_strategy = self.knowledge.choose_strategy()\r\n        print(f"Chosen strategy for this match: {self.current_strategy.upper()}")\r\n\r\n    async def on_step(self, iteration: int):\r\n        """Execute the chosen strategy."""\r\n        # A very simple aggressive strategy for demonstration purposes.\r\n        if self.current_strategy == "aggressive" and self.units.idle.amount > 10:\r\n            for unit in self.units.idle:\r\n                unit.attack(self.enemy_start_locations[0])\r\n\r\n    async def on_end(self, game_result: Result):\r\n        """Update and save knowledge with the result of this match."""\r\n        print(f"Match ended with result: {game_result}")\r\n        self.knowledge.update_result(self.current_strategy, game_result)\r\n        self.knowledge.save()\r\n\r\n\r\nif __name__ == "__main__":\r\n    run_game(\r\n        maps.get("GresvanAIE"),\r\n        [\r\n            Bot(Race.Terran, AdaptiveBot()),\r\n            Computer(Race.Zerg, Difficulty.Easy)\r\n        ],\r\n        realtime=False,\r\n    )\n'})})]})}function h(e={}){const{wrapper:t}={...(0,a.R)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(c,{...e})}):c(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>o,x:()=>i});var s=n(6540);const r={},a=s.createContext(r);function o(e){const t=s.useContext(a);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function i(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),s.createElement(a.Provider,{value:t},e.children)}}}]);