"use strict";(self.webpackChunkmy_framework_docs=self.webpackChunkmy_framework_docs||[]).push([[2691],{7282:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>r,metadata:()=>a,toc:()=>d});const a=JSON.parse('{"id":"Part 4 - The Wider World/Chapter 8 - Bot Vision - Advantages and Limitations/8.1 - What Your Bot Sees That a Human Can\'t - API Advantages","title":"8.1 - What Your Bot Sees That a Human Can\'t - API Advantages","description":"Your bot is not a human. It \\"sees\\" the game through a direct data feed from the StarCraft II API, giving it several inherent perceptual advantages. These are not cheats; they are natural consequences of the API\'s design. Understanding these advantages is crucial because it frees you from writing complex code to simulate abilities your bot already has.","source":"@site/docs/Part 4 - The Wider World/Chapter 8 - Bot Vision - Advantages and Limitations/8.1 - What Your Bot Sees That a Human Can\'t - API Advantages.md","sourceDirName":"Part 4 - The Wider World/Chapter 8 - Bot Vision - Advantages and Limitations","slug":"/Part 4 - The Wider World/Chapter 8 - Bot Vision - Advantages and Limitations/8.1 - What Your Bot Sees That a Human Can\'t - API Advantages","permalink":"/learn-python-sc2/docs/Part 4 - The Wider World/Chapter 8 - Bot Vision - Advantages and Limitations/8.1 - What Your Bot Sees That a Human Can\'t - API Advantages","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"7.4 - Saving Data Between Matches","permalink":"/learn-python-sc2/docs/Part 3 - Advanced Development/Chapter 7 - Performance and Debugging/7.4 - Saving Data Between Matches"},"next":{"title":"8.2 - What Your Bot Can\'t See - API Limitations","permalink":"/learn-python-sc2/docs/Part 4 - The Wider World/Chapter 8 - Bot Vision - Advantages and Limitations/8.2 - What Your Bot Can\'t See - API Limitations"}}');var s=n(4848),i=n(8453);const r={},o=void 0,l={},d=[{value:"<strong>The Human vs. The Bot: A Perceptual Comparison</strong>",id:"the-human-vs-the-bot-a-perceptual-comparison",level:4},{value:"<strong>Key API Advantages</strong>",id:"key-api-advantages",level:4},{value:"<strong>Developer&#39;s Checklist: Leveraging API Advantages</strong>",id:"developers-checklist-leveraging-api-advantages",level:4},{value:"<strong>Code Example: The &quot;All-Seeing&quot; Bot</strong>",id:"code-example-the-all-seeing-bot",level:4}];function c(e){const t={code:"code",em:"em",h4:"h4",hr:"hr",input:"input",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.p,{children:'Your bot is not a human. It "sees" the game through a direct data feed from the StarCraft II API, giving it several inherent perceptual advantages. These are not cheats; they are natural consequences of the API\'s design. Understanding these advantages is crucial because it frees you from writing complex code to simulate abilities your bot already has.'}),"\n",(0,s.jsxs)(t.p,{children:["Your bot is, in essence, a ",(0,s.jsx)(t.strong,{children:"perfect observer of all visible information"}),". Its challenge is not in perceiving the game, but in making intelligent decisions based on the perfect data it receives."]}),"\n",(0,s.jsx)(t.h4,{id:"the-human-vs-the-bot-a-perceptual-comparison",children:(0,s.jsx)(t.strong,{children:"The Human vs. The Bot: A Perceptual Comparison"})}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{children:"+------------------------------------------+       +-----------------------------------------+\r\n|                Human Player              |       |               Your Bot                  |\r\n|==========================================|       |=========================================|\r\n|  - Vision is a fuzzy, analog signal.     |       |  - Vision is a discrete, digital grid.  |\r\n|  - Relies on visual cues (shimmers).     |       |  - Gets exact unit data instantly.      |\r\n|  - Memory is fallible.                   |       |  - Memory is perfect (via unit tags).   |\r\n|  - Calculations are approximate.         |       |  - Calculations are flawless.           |\r\n|  - Reaction time is measured in ms.      |       |  - Reaction time is near-instant.       |\r\n+------------------------------------------+       +-----------------------------------------+\n"})}),"\n",(0,s.jsx)(t.hr,{}),"\n",(0,s.jsx)(t.h4,{id:"key-api-advantages",children:(0,s.jsx)(t.strong,{children:"Key API Advantages"})}),"\n",(0,s.jsxs)(t.table,{children:[(0,s.jsx)(t.thead,{children:(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.th,{style:{textAlign:"left"},children:"Advantage"}),(0,s.jsx)(t.th,{style:{textAlign:"left"},children:"Human Limitation"}),(0,s.jsx)(t.th,{style:{textAlign:"left"},children:"Your Bot's Reality"}),(0,s.jsx)(t.th,{style:{textAlign:"left"},children:"Developer Takeaway"})]})}),(0,s.jsxs)(t.tbody,{children:[(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{style:{textAlign:"left"},children:(0,s.jsx)(t.strong,{children:"1. Perfect Detection"})}),(0,s.jsx)(t.td,{style:{textAlign:"left"},children:'Must visually spot the "shimmer" of a cloaked unit. May be fooled by a Changeling\'s disguise, at least temporarily.'}),(0,s.jsxs)(t.td,{style:{textAlign:"left"},children:["If a detector (e.g., Observer, Raven, Spore Crawler) makes a cloaked unit visible, your bot instantly knows its ",(0,s.jsx)(t.code,{children:"type_id"})," and exact ",(0,s.jsx)(t.code,{children:"position"}),". It cannot be tricked by a Changeling ",(0,s.jsx)(t.em,{children:"once it has been revealed"}),"."]}),(0,s.jsx)(t.td,{style:{textAlign:"left"},children:'You don\'t need to write code to "detect" shimmers. You only need to write logic to bring a detector and then react to the perfectly-provided information.'})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{style:{textAlign:"left"},children:(0,s.jsx)(t.strong,{children:"2. Flawless Memory"})}),(0,s.jsx)(t.td,{style:{textAlign:"left"},children:"May forget which units were in a specific army or lose track of a key enemy unit that moved out of vision."}),(0,s.jsxs)(t.td,{style:{textAlign:"left"},children:["Every unit has a permanent ",(0,s.jsx)(t.code,{children:"tag"}),". Your bot can track a specific enemy unit for the entire game, even if it disappears and reappears."]}),(0,s.jsxs)(t.td,{style:{textAlign:"left"},children:["Use ",(0,s.jsx)(t.code,{children:"unit.tag"})," to track high-value targets. You will always know if it's the same unit you saw earlier."]})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{style:{textAlign:"left"},children:(0,s.jsx)(t.strong,{children:"3. Instantaneous Calculation"})}),(0,s.jsx)(t.td,{style:{textAlign:"left"},children:"Must estimate attack ranges and splash damage radii, leading to errors in positioning."}),(0,s.jsxs)(t.td,{style:{textAlign:"left"},children:["The bot can use ",(0,s.jsx)(t.code,{children:"unit.target_in_range()"})," and pre-programmed splash data to calculate threats with perfect precision."]}),(0,s.jsx)(t.td,{style:{textAlign:"left"},children:"Trust the API for range checks. Your kiting and positioning logic can be pixel-perfect."})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{style:{textAlign:"left"},children:(0,s.jsx)(t.strong,{children:"4. Zero Latency Commands"})}),(0,s.jsx)(t.td,{style:{textAlign:"left"},children:"Has a physical and mental delay between seeing an event and reacting to it."}),(0,s.jsx)(t.td,{style:{textAlign:"left"},children:"Your bot can issue a command in the same game step it receives the data, allowing for reactions impossible for a human."}),(0,s.jsx)(t.td,{style:{textAlign:"left"},children:"Your micro-management logic can be incredibly responsive (e.g., splitting units the instant a projectile is fired)."})]})]})]}),"\n",(0,s.jsx)(t.hr,{}),"\n",(0,s.jsx)(t.h4,{id:"developers-checklist-leveraging-api-advantages",children:(0,s.jsx)(t.strong,{children:"Developer's Checklist: Leveraging API Advantages"})}),"\n",(0,s.jsx)(t.p,{children:"When designing your bot's logic, remember what you get for free:"}),"\n",(0,s.jsxs)(t.ul,{className:"contains-task-list",children:["\n",(0,s.jsxs)(t.li,{className:"task-list-item",children:[(0,s.jsx)(t.input,{type:"checkbox",disabled:!0})," ",(0,s.jsx)(t.strong,{children:'Don\'t code a "shimmer detector."'})," The API gives you no data on shimmers. Focus on getting a detector to the right place; the API will do the rest."]}),"\n",(0,s.jsxs)(t.li,{className:"task-list-item",children:[(0,s.jsx)(t.input,{type:"checkbox",disabled:!0})," ",(0,s.jsx)(t.strong,{children:"Don't assume you can see through disguises."})," A Changeling will report the ",(0,s.jsx)(t.code,{children:"type_id"})," it's disguised as. React to it once it's revealed (by damage, detection, or transformation)."]}),"\n",(0,s.jsxs)(t.li,{className:"task-list-item",children:[(0,s.jsx)(t.input,{type:"checkbox",disabled:!0})," ",(0,s.jsxs)(t.strong,{children:["Trust the ",(0,s.jsx)(t.code,{children:"tag"}),"."]}),' Use it to maintain a "most wanted" list of dangerous enemy units.']}),"\n",(0,s.jsxs)(t.li,{className:"task-list-item",children:[(0,s.jsx)(t.input,{type:"checkbox",disabled:!0})," ",(0,s.jsx)(t.strong,{children:"Trust the math."})," Use the provided distance and range functions to build precise micro-management routines."]}),"\n"]}),"\n",(0,s.jsx)(t.hr,{}),"\n",(0,s.jsx)(t.h4,{id:"code-example-the-all-seeing-bot",children:(0,s.jsx)(t.strong,{children:'Code Example: The "All-Seeing" Bot'})}),"\n",(0,s.jsxs)(t.p,{children:["This bot demonstrates how to leverage these API advantages. It instantly identifies cloaked units and Changelings ",(0,s.jsx)(t.em,{children:"once they are properly revealed"})," and logs them."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-python",children:'# all_seeing_bot.py\r\n\r\nfrom sc2 import maps\r\nfrom sc2.bot_ai import BotAI\r\nfrom sc2.data import Difficulty, Race\r\nfrom sc2.main import run_game\r\nfrom sc2.player import Bot, Computer\r\nfrom sc2.ids.unit_typeid import UnitTypeId as Id\r\n\r\nclass AllSeeingBot(BotAI):\r\n    """A bot that demonstrates the API\'s perceptual advantages."""\r\n\r\n    def __init__(self):\r\n        super().__init__()\r\n        # Use sets for fast, duplicate-free tracking of seen units.\r\n        self.seen_cloaked_tags = set()\r\n        self.seen_changeling_tags = set()\r\n\r\n    async def on_step(self, iteration: int):\r\n        # Loop through all VISIBLE enemy units on every step.\r\n        # This list only includes units that are not cloaked or have been revealed by a detector.\r\n        for enemy in self.enemy_units:\r\n            # ADVANTAGE 1: PERFECT DETECTION OF REVEALED CLOAKED UNITS\r\n            # If a detector is present, the bot instantly knows the unit is cloaked.\r\n            if enemy.is_cloaked and enemy.tag not in self.seen_cloaked_tags:\r\n                self.seen_cloaked_tags.add(enemy.tag)\r\n                print(f"[{self.time_formatted}] API ADVANTAGE: Instantly detected a cloaked {enemy.name} at {enemy.position.rounded} because a detector was present.")\r\n\r\n            # ADVANTAGE 2: PERFECT DETECTION OF REVEALED CHANGELINGS\r\n            # The bot knows the unit\'s true type_id once it is revealed.\r\n            if enemy.type_id == Id.CHANGELING and enemy.tag not in self.seen_changeling_tags:\r\n                self.seen_changeling_tags.add(enemy.tag)\r\n                print(f"[{self.time_formatted}] API ADVANTAGE: Instantly identified a revealed Changeling at {enemy.position.rounded}.")\r\n\r\n        # ADVANTAGE 3 & 4: FLAWLESS CALCULATION AND REACTION\r\n        # This logic demonstrates perfect kiting, a feat of calculation and reaction.\r\n        # Each marine will react to the closest threat to it.\r\n        if self.units(Id.MARINE).exists and self.enemy_units.exists:\r\n            for marine in self.units(Id.MARINE):\r\n                closest_enemy = self.enemy_units.closest_to(marine)\r\n                # If weapon is on cooldown, move away\r\n                if marine.weapon_cooldown > 0:\r\n                    marine.move(marine.position.towards(closest_enemy.position, -1))\r\n                # Otherwise, attack\r\n                else:\r\n                    marine.attack(closest_enemy)\r\n\r\n\r\nif __name__ == "__main__":\r\n    run_game(\r\n        maps.get("GresvanAIE"),\r\n        [\r\n            Bot(Race.Terran, AllSeeingBot()),\r\n            # We use a Zerg opponent because they have access to both cloaked units (Lurkers, Infestors) and changelings.\r\n            Computer(Race.Zerg, Difficulty.Medium)\r\n        ],\r\n        realtime=True,\r\n    )\n'})})]})}function h(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>r,x:()=>o});var a=n(6540);const s={},i=a.createContext(s);function r(e){const t=a.useContext(i);return a.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),a.createElement(i.Provider,{value:t},e.children)}}}]);