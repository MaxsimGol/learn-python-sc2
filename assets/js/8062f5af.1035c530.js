"use strict";(self.webpackChunkmy_framework_docs=self.webpackChunkmy_framework_docs||[]).push([[4205],{3116:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>a,default:()=>h,frontMatter:()=>o,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"Part 5 - Reinforcement Learning/Foundations of Reinforcement Learning/Chapter 6 - Training Your Agents/6.2 - A Quick Look at the PPO Algorithm","title":"6.2 - A Quick Look at the PPO Algorithm","description":"Our training script utilizes Proximal Policy Optimization (PPO), a state-of-the-art reinforcement learning algorithm from the family of policy gradient methods. For the developer, PPO\'s primary appeal is its exceptional balance of sample efficiency, ease of implementation, and stability, making it a robust and reliable choice for a wide range of problems.","source":"@site/docs/Part 5 - Reinforcement Learning/1 - Foundations of Reinforcement Learning/Chapter 6 - Training Your Agents/6.2 - A Quick Look at the PPO Algorithm.md","sourceDirName":"Part 5 - Reinforcement Learning/1 - Foundations of Reinforcement Learning/Chapter 6 - Training Your Agents","slug":"/Part 5 - Reinforcement Learning/Foundations of Reinforcement Learning/Chapter 6 - Training Your Agents/6.2 - A Quick Look at the PPO Algorithm","permalink":"/learn-python-sc2/docs/Part 5 - Reinforcement Learning/Foundations of Reinforcement Learning/Chapter 6 - Training Your Agents/6.2 - A Quick Look at the PPO Algorithm","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"6.1 - Code - The Reusable train.py Script","permalink":"/learn-python-sc2/docs/Part 5 - Reinforcement Learning/Foundations of Reinforcement Learning/Chapter 6 - Training Your Agents/6.1 - Code - The Reusable train.py Script"},"next":{"title":"6.3 - Loading and Running a Trained Agent","permalink":"/learn-python-sc2/docs/Part 5 - Reinforcement Learning/Foundations of Reinforcement Learning/Chapter 6 - Training Your Agents/6.3 - Loading and Running a Trained Agent"}}');var r=n(4848),s=n(8453);const o={},a=void 0,l={},c=[{value:"<strong>Core Concept- Constrained Policy Updates</strong>",id:"core-concept--constrained-policy-updates",level:4},{value:"<strong>When to Use PPO- A Developer&#39;s Checklist</strong>",id:"when-to-use-ppo--a-developers-checklist",level:4},{value:"<strong>Key Hyperparameters for Tuning</strong>",id:"key-hyperparameters-for-tuning",level:4}];function d(e){const t={code:"code",h4:"h4",hr:"hr",input:"input",li:"li",p:"p",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,s.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(t.p,{children:["Our training script utilizes ",(0,r.jsx)(t.strong,{children:"Proximal Policy Optimization (PPO)"}),", a state-of-the-art reinforcement learning algorithm from the family of policy gradient methods. For the developer, PPO's primary appeal is its exceptional balance of sample efficiency, ease of implementation, and stability, making it a robust and reliable choice for a wide range of problems."]}),"\n",(0,r.jsx)(t.p,{children:"This section provides a high-level, practical overview of PPO's core concept and its key hyperparameters."}),"\n",(0,r.jsx)(t.h4,{id:"core-concept--constrained-policy-updates",children:(0,r.jsx)(t.strong,{children:"Core Concept- Constrained Policy Updates"})}),"\n",(0,r.jsx)(t.p,{children:'The central challenge in policy gradient methods is determining the correct step size for policy updates. An update that is too large can catastrophically "forget" previous learning, while an update that is too small can lead to inefficiently slow training.'}),"\n",(0,r.jsxs)(t.p,{children:["PPO solves this by enforcing a ",(0,r.jsx)(t.strong,{children:"trust region"}),". It optimizes a clipped objective function that prevents the new policy from deviating too drastically from the old one in a single update step."]}),"\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.strong,{children:"Analogy- Gradient Descent with a Safety Harness"}),"\r\nThink of standard policy gradients as walking down a hill (gradient descent). You might take a huge leap and end up in a completely different, unintended valley. PPO is like using a safety harness that only lets you take a small, controlled step each time, ensuring you don't stray too far from your current stable footing."]}),"\n",(0,r.jsx)(t.h4,{id:"when-to-use-ppo--a-developers-checklist",children:(0,r.jsx)(t.strong,{children:"When to Use PPO- A Developer's Checklist"})}),"\n",(0,r.jsx)(t.p,{children:"PPO is an excellent default choice for many RL applications."}),"\n",(0,r.jsxs)(t.ul,{className:"contains-task-list",children:["\n",(0,r.jsxs)(t.li,{className:"task-list-item",children:[(0,r.jsx)(t.input,{type:"checkbox",checked:!0,disabled:!0})," ",(0,r.jsx)(t.strong,{children:"You need a stable and reliable algorithm."})," PPO is less prone to catastrophic performance collapses during training than many other methods."]}),"\n",(0,r.jsxs)(t.li,{className:"task-list-item",children:[(0,r.jsx)(t.input,{type:"checkbox",checked:!0,disabled:!0})," ",(0,r.jsx)(t.strong,{children:"Your problem has a continuous or large discrete action space."})," (Though it also excels at simple discrete spaces)."]}),"\n",(0,r.jsxs)(t.li,{className:"task-list-item",children:[(0,r.jsx)(t.input,{type:"checkbox",checked:!0,disabled:!0})," ",(0,r.jsx)(t.strong,{children:"You want good results without extensive hyperparameter tuning."})," PPO's defaults are often very effective."]}),"\n",(0,r.jsxs)(t.li,{className:"task-list-item",children:[(0,r.jsx)(t.input,{type:"checkbox",checked:!0,disabled:!0})," ",(0,r.jsx)(t.strong,{children:"You need an algorithm that can be easily parallelized"})," to collect experience from multiple environments simultaneously."]}),"\n"]}),"\n",(0,r.jsx)(t.hr,{}),"\n",(0,r.jsx)(t.h4,{id:"key-hyperparameters-for-tuning",children:(0,r.jsx)(t.strong,{children:"Key Hyperparameters for Tuning"})}),"\n",(0,r.jsxs)(t.p,{children:["While the ",(0,r.jsx)(t.code,{children:"stable-baselines3"})," defaults are excellent, understanding these key hyperparameters is essential for performance tuning on more complex tasks."]}),"\n",(0,r.jsxs)(t.table,{children:[(0,r.jsx)(t.thead,{children:(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.th,{style:{textAlign:"left"},children:"Hyperparameter"}),(0,r.jsx)(t.th,{style:{textAlign:"left"},children:"Technical Role"}),(0,r.jsx)(t.th,{style:{textAlign:"left"},children:"Developer's Rule of Thumb"})]})}),(0,r.jsxs)(t.tbody,{children:[(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{style:{textAlign:"left"},children:(0,r.jsx)(t.strong,{children:(0,r.jsx)(t.code,{children:"learning_rate"})})}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:"The step size for the Adam optimizer."}),(0,r.jsxs)(t.td,{style:{textAlign:"left"},children:[(0,r.jsx)(t.strong,{children:"The most important parameter."})," If your reward is not increasing, try lowering this (e.g., ",(0,r.jsx)(t.code,{children:"1e-4"}),"). If it's learning too slowly, try a slight increase."]})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{style:{textAlign:"left"},children:(0,r.jsx)(t.strong,{children:(0,r.jsx)(t.code,{children:"n_steps"})})}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:"The number of steps to run for each environment per policy update."}),(0,r.jsxs)(t.td,{style:{textAlign:"left"},children:[(0,r.jsx)(t.strong,{children:"Memory vs. Stability."})," A larger value provides more data diversity per update, leading to more stable training, but consumes more memory."]})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{style:{textAlign:"left"},children:(0,r.jsx)(t.strong,{children:(0,r.jsx)(t.code,{children:"batch_size"})})}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:"The size of the mini-batches used to compute the gradient during the update."}),(0,r.jsxs)(t.td,{style:{textAlign:"left"},children:[(0,r.jsxs)(t.strong,{children:["Should be a factor of ",(0,r.jsx)(t.code,{children:"n_steps"}),"."]})," Smaller batches can lead to faster but noisier updates. ",(0,r.jsx)(t.code,{children:"64"})," is a common starting point."]})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{style:{textAlign:"left"},children:(0,r.jsx)(t.strong,{children:(0,r.jsx)(t.code,{children:"gamma"})})}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:"The discount factor for future rewards."}),(0,r.jsxs)(t.td,{style:{textAlign:"left"},children:[(0,r.jsx)(t.strong,{children:"Problem Horizon."})," For tasks with long-term consequences (like SC2), keep this high (e.g., ",(0,r.jsx)(t.code,{children:"0.99"})," to ",(0,r.jsx)(t.code,{children:"0.999"}),"). For tasks with only immediate rewards, a lower value is acceptable."]})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{style:{textAlign:"left"},children:(0,r.jsx)(t.strong,{children:(0,r.jsx)(t.code,{children:"ent_coef"})})}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:"The entropy coefficient. Encourages exploration by penalizing an overly confident (low-entropy) policy."}),(0,r.jsxs)(t.td,{style:{textAlign:"left"},children:[(0,r.jsx)(t.strong,{children:"Exploration vs. Exploitation."})," If your agent converges on a poor, repetitive strategy, try slightly increasing this value to encourage more exploration."]})]})]})]}),"\n",(0,r.jsx)(t.p,{children:"For our initial tasks, the default hyperparameters are sufficient. However, as you tackle more complex strategic challenges, a methodical approach to tuning these values will be crucial for achieving optimal performance."})]})}function h(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>o,x:()=>a});var i=n(6540);const r={},s=i.createContext(r);function o(e){const t=i.useContext(s);return i.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),i.createElement(s.Provider,{value:t},e.children)}}}]);