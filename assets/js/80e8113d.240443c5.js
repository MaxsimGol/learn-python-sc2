"use strict";(self.webpackChunkmy_framework_docs=self.webpackChunkmy_framework_docs||[]).push([[2539],{600:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>o,contentTitle:()=>l,default:()=>h,frontMatter:()=>a,metadata:()=>i,toc:()=>d});const i=JSON.parse('{"id":"Part 3 - Advanced Development/Chapter 6 - Building a Smarter Bot/6.3 - Querying the Game - Checking for Pathing and Abilities","title":"6.3 - Querying the Game - Checking for Pathing and Abilities","description":"Your bot\'s standard senses (self.state and its helpers) provide a snapshot of what is. But to make truly intelligent decisions, your bot needs to ask what could be. Can a unit get from A to B? Is an ability actually ready to use? Answering these questions requires querying the game engine for a specific calculation.","source":"@site/docs/Part 3 - Advanced Development/Chapter 6 - Building a Smarter Bot/6.3 - Querying the Game - Checking for Pathing and Abilities.md","sourceDirName":"Part 3 - Advanced Development/Chapter 6 - Building a Smarter Bot","slug":"/Part 3 - Advanced Development/Chapter 6 - Building a Smarter Bot/6.3 - Querying the Game - Checking for Pathing and Abilities","permalink":"/learn-python-sc2/docs/Part 3 - Advanced Development/Chapter 6 - Building a Smarter Bot/6.3 - Querying the Game - Checking for Pathing and Abilities","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"6.2 - Micro-management - Controlling Units in Combat","permalink":"/learn-python-sc2/docs/Part 3 - Advanced Development/Chapter 6 - Building a Smarter Bot/6.2 - Micro-management - Controlling Units in Combat"},"next":{"title":"7.1 - Writing Efficient Code - Managing APM","permalink":"/learn-python-sc2/docs/Part 3 - Advanced Development/Chapter 7 - Performance and Debugging/7.1 - Writing Efficient Code - Managing APM"}}');var s=t(4848),r=t(8453);const a={},l=void 0,o={},d=[{value:"<strong>The Query System</strong>",id:"the-query-system",level:4},{value:"<strong>The Three Essential Queries</strong>",id:"the-three-essential-queries",level:4},{value:"<strong>A Developer&#39;s Checklist for Using Queries</strong>",id:"a-developers-checklist-for-using-queries",level:4},{value:"<strong>Code Example: The &quot;Inquisitive&quot; Bot</strong>",id:"code-example-the-inquisitive-bot",level:4}];function c(e){const n={code:"code",em:"em",h4:"h4",hr:"hr",input:"input",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.p,{children:["Your bot's standard senses (",(0,s.jsx)(n.code,{children:"self.state"})," and its helpers) provide a snapshot of what ",(0,s.jsx)(n.em,{children:"is"}),". But to make truly intelligent decisions, your bot needs to ask what ",(0,s.jsx)(n.em,{children:"could be"}),". Can a unit get from A to B? Is an ability actually ready to use? Answering these questions requires ",(0,s.jsx)(n.strong,{children:"querying"})," the game engine for a specific calculation."]}),"\n",(0,s.jsxs)(n.p,{children:["Queries are ",(0,s.jsx)(n.code,{children:"async"})," functions that send a request to the StarCraft II engine and ",(0,s.jsx)(n.code,{children:"await"})," a response. They are essential tools for moving beyond simple reactive logic to proactive, error-proof planning."]}),"\n",(0,s.jsx)(n.h4,{id:"the-query-system",children:(0,s.jsx)(n.strong,{children:"The Query System"})}),"\n",(0,s.jsx)(n.p,{children:"Think of a query as a direct question to the game engine's internal rulebook."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:'+------------------+\r\n|                  |   1. "Can a Marine walk from my base to this island?"\r\n|  Your Python Bot | --------------------------------------------------\x3e +---------------+\r\n|   (The Querier)  |                                                     |               |\r\n|                  |   2. "No, the path distance is None."               |  SC2 Game     |\r\n|                  | <-------------------------------------------------- |   Engine      |\r\n+------------------+                                                     |  (The Oracle) |\r\n                                                                         +---------------+\n'})}),"\n",(0,s.jsx)(n.p,{children:"This request-response cycle allows your bot to validate its plans before committing resources."}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h4,{id:"the-three-essential-queries",children:(0,s.jsx)(n.strong,{children:"The Three Essential Queries"})}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{style:{textAlign:"left"},children:"Query"}),(0,s.jsx)(n.th,{style:{textAlign:"left"},children:"Key Function"}),(0,s.jsx)(n.th,{style:{textAlign:"left"},children:"What It Asks"}),(0,s.jsx)(n.th,{style:{textAlign:"left"},children:"When to Use It"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{style:{textAlign:"left"},children:(0,s.jsx)(n.strong,{children:"Placement"})}),(0,s.jsx)(n.td,{style:{textAlign:"left"},children:(0,s.jsx)(n.code,{children:"await self.find_placement(...)"})}),(0,s.jsx)(n.td,{style:{textAlign:"left"},children:'"Where is a valid spot to build this structure?"'}),(0,s.jsxs)(n.td,{style:{textAlign:"left"},children:[(0,s.jsx)(n.strong,{children:"Always."})," Before every ",(0,s.jsx)(n.code,{children:"self.build"})," command to ensure the location is legal."]})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{style:{textAlign:"left"},children:(0,s.jsx)(n.strong,{children:"Pathing"})}),(0,s.jsx)(n.td,{style:{textAlign:"left"},children:(0,s.jsx)(n.code,{children:"await self.client.query_pathing(...)"})}),(0,s.jsx)(n.td,{style:{textAlign:"left"},children:'"Is there a walkable ground path from point A to point B?"'}),(0,s.jsx)(n.td,{style:{textAlign:"left"},children:'Before sending a ground unit to a distant location, especially a potential expansion, to avoid "island" traps.'})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{style:{textAlign:"left"},children:(0,s.jsx)(n.strong,{children:"Ability"})}),(0,s.jsx)(n.td,{style:{textAlign:"left"},children:(0,s.jsx)(n.code,{children:"await self.get_available_abilities(...)"})}),(0,s.jsxs)(n.td,{style:{textAlign:"left"},children:['"Which abilities can this specific unit use ',(0,s.jsx)(n.em,{children:"right now"}),'?"']}),(0,s.jsxs)(n.td,{style:{textAlign:"left"},children:[(0,s.jsx)(n.strong,{children:"Always."})," Before casting any ability with a cooldown to ensure it's not on cooldown. This is more reliable than just checking energy."]})]})]})]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h4,{id:"a-developers-checklist-for-using-queries",children:(0,s.jsx)(n.strong,{children:"A Developer's Checklist for Using Queries"})}),"\n",(0,s.jsxs)(n.ul,{className:"contains-task-list",children:["\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ",(0,s.jsx)(n.strong,{children:"1. Identify the Question:"}),' What do I need to know before I act? (e.g., "Is this expansion on an island?")']}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ",(0,s.jsx)(n.strong,{children:"2. Choose the Right Query:"})," Select the function that answers your question (",(0,s.jsx)(n.code,{children:"query_pathing"}),", ",(0,s.jsx)(n.code,{children:"get_available_abilities"}),", etc.)."]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ",(0,s.jsxs)(n.strong,{children:["3. ",(0,s.jsx)(n.code,{children:"await"})," the Response:"]})," Since queries are network requests, you must ",(0,s.jsx)(n.code,{children:"await"})," the result."]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ",(0,s.jsx)(n.strong,{children:"4. Handle the Response:"})," The query might return ",(0,s.jsx)(n.code,{children:"None"})," or an empty list if the answer is negative. Your code must handle this gracefully.","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"if path_distance is None:"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"if AbilityId.STIMPACK in available_abilities:"})}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ",(0,s.jsx)(n.strong,{children:"5. Act on the Verified Information:"})," Only issue your command ",(0,s.jsx)(n.em,{children:"after"})," the query has confirmed it's a valid action."]}),"\n"]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h4,{id:"code-example-the-inquisitive-bot",children:(0,s.jsx)(n.strong,{children:'Code Example: The "Inquisitive" Bot'})}),"\n",(0,s.jsxs)(n.p,{children:["This bot demonstrates how to use queries to make its decisions more robust. It will use a ",(0,s.jsx)(n.strong,{children:"pathing query"})," to verify that its next expansion is reachable and an ",(0,s.jsx)(n.strong,{children:"ability query"})," to ensure its Stimpack command is valid."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'# inquisitive_bot.py\r\n\r\nfrom sc2 import maps\r\nfrom sc2.bot_ai import BotAI\r\nfrom sc2.data import Difficulty, Race\r\nfrom sc2.main import run_game\r\nfrom sc2.player import Bot, Computer\r\nfrom sc2.ids.unit_typeid import UnitTypeId\r\nfrom sc2.ids.ability_id import AbilityId\r\n\r\nclass InquisitiveBot(BotAI):\r\n    """A bot that uses queries to make smarter decisions."""\r\n\r\n    async def on_step(self, iteration: int):\r\n        await self.manage_expansion()\r\n        await self.manage_stimpack()\r\n        # Helper to build an army for the demo.\r\n        await self.build_army()\r\n\r\n    async def manage_expansion(self):\r\n        """Uses a pathing query to safely expand."""\r\n        # Only try to expand if we have 1 base and can afford it.\r\n        if len(self.townhalls) == 1 and self.can_afford(UnitTypeId.COMMANDCENTER):\r\n            # Find the location of the next expansion spot.\r\n            next_expansion_location = await self.get_next_expansion()\r\n            if not next_expansion_location:\r\n                return\r\n\r\n            # QUERY: Can a worker walk from our start to the expansion?\r\n            path_distance = await self.client.query_pathing(self.start_location, next_expansion_location)\r\n\r\n            # HANDLE RESPONSE:\r\n            if path_distance is None:\r\n                # The path is blocked (e.g., an island). Do not expand.\r\n                print(f"WARNING: Expansion at {next_expansion_location} is unreachable by ground.")\r\n            else:\r\n                # The path is clear. Proceed with the expansion.\r\n                print(f"INFO: Expansion is reachable (Distance: {path_distance:.2f}). Expanding.")\r\n                await self.expand_now()\r\n\r\n    async def manage_stimpack(self):\r\n        """Uses an ability query to safely use Stimpack."""\r\n        # Find marines near enemies.\r\n        marines_in_danger = self.units(UnitTypeId.MARINE).filter(\r\n            lambda m: self.enemy_units.closer_than(10, m).exists\r\n        )\r\n\r\n        for marine in marines_in_danger:\r\n            # QUERY: What abilities can this specific marine use right now?\r\n            available_abilities = await self.get_available_abilities(marine)\r\n            # HANDLE RESPONSE: Check if Stimpack is in the list.\r\n            if AbilityId.STIMPACK in available_abilities:\r\n                print(f"INFO: Marine {marine.tag} is using Stimpack.")\r\n                marine(AbilityId.STIMPACK)\r\n\r\n    async def build_army(self):\r\n        """A simple helper method to produce units for the demo."""\r\n        if self.supply_left < 2 and not self.already_pending(UnitTypeId.SUPPLYDEPOT):\r\n            if self.can_afford(UnitTypeId.SUPPLYDEPOT):\r\n                await self.build(UnitTypeId.SUPPLYDEPOT, near=self.start_location.towards(self.game_info.map_center, 5))\r\n        if not self.structures(UnitTypeId.BARRACKS).exists:\r\n            if self.can_afford(UnitTypeId.BARRACKS):\r\n                await self.build(UnitTypeId.BARRACKS, near=self.start_location.towards(self.game_info.map_center, 8))\r\n        elif self.structures(UnitTypeId.BARRACKS).ready.idle.exists and self.can_afford(UnitTypeId.MARINE):\r\n            self.train(UnitTypeId.MARINE)\r\n\r\n\r\nif __name__ == "__main__":\r\n    run_game(\r\n        maps.get("BlackburnAIE"),\r\n        [\r\n            Bot(Race.Terran, InquisitiveBot()),\r\n            Computer(Race.Zerg, Difficulty.Medium)\r\n        ],\r\n        realtime=True,\r\n    )\n'})})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>l});var i=t(6540);const s={},r=i.createContext(s);function a(e){const n=i.useContext(r);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),i.createElement(r.Provider,{value:n},e.children)}}}]);