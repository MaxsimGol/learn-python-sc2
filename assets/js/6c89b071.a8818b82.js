"use strict";(self.webpackChunkmy_framework_docs=self.webpackChunkmy_framework_docs||[]).push([[1229],{8257:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>o,contentTitle:()=>l,default:()=>h,frontMatter:()=>a,metadata:()=>i,toc:()=>d});const i=JSON.parse('{"id":"Part 2 - Core Concepts/Chapter 5 - Issuing Commands - Actions/5.5 - Using Special Abilities","title":"5.5 - Using Special Abilities","description":"Beyond basic commands, many units have powerful abilities that define high-level strategy\u2014a Sentry\'s Force Field, a Ghost\'s Snipe, or a Queen\'s Inject Larva. The library provides a direct and intuitive syntax for using these abilities by making the Unit object itself \\"callable.\\"","source":"@site/docs/Part 2 - Core Concepts/Chapter 5 - Issuing Commands - Actions/5.5 - Using Special Abilities.md","sourceDirName":"Part 2 - Core Concepts/Chapter 5 - Issuing Commands - Actions","slug":"/Part 2 - Core Concepts/Chapter 5 - Issuing Commands - Actions/5.5 - Using Special Abilities","permalink":"/learn-python-sc2/docs/Part 2 - Core Concepts/Chapter 5 - Issuing Commands - Actions/5.5 - Using Special Abilities","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"5.4 - Production- Training Units and Researching Upgrades","permalink":"/learn-python-sc2/docs/Part 2 - Core Concepts/Chapter 5 - Issuing Commands - Actions/5.4 - Production- Training Units and Researching Upgrades"},"next":{"title":"6.1 - Macro-management - Expanding and Managing Your Economy","permalink":"/learn-python-sc2/docs/Part 3 - Advanced Development/Chapter 6 - Building a Smarter Bot/6.1 - Macro-management - Expanding and Managing Your Economy"}}');var r=t(4848),s=t(8453);const a={},l=void 0,o={},d=[{value:"<strong>The Callable Unit: A Unified Syntax</strong>",id:"the-callable-unit-a-unified-syntax",level:4},{value:"<strong>Deep Dive 1- The <code>queue</code> Parameter</strong>",id:"deep-dive-1--the-queue-parameter",level:4},{value:"<strong>Deep Dive 2- <code>self.get_available_abilities()</code></strong>",id:"deep-dive-2--selfget_available_abilities",level:4},{value:"<strong>The Professional Ability Workflow</strong>",id:"the-professional-ability-workflow",level:4},{value:"<strong>Code Example- The Zerg Matriarch Bot</strong>",id:"code-example--the-zerg-matriarch-bot",level:4}];function c(e){const n={code:"code",em:"em",h4:"h4",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,s.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.p,{children:["Beyond basic commands, many units have powerful abilities that define high-level strategy\u2014a Sentry's Force Field, a Ghost's Snipe, or a Queen's Inject Larva. The library provides a direct and intuitive syntax for using these abilities by making the ",(0,r.jsx)(n.code,{children:"Unit"}),' object itself "callable."']}),"\n",(0,r.jsx)(n.h4,{id:"the-callable-unit-a-unified-syntax",children:(0,r.jsx)(n.strong,{children:"The Callable Unit: A Unified Syntax"})}),"\n",(0,r.jsxs)(n.p,{children:["The core method for using any ability is to treat the ",(0,r.jsx)(n.code,{children:"Unit"})," object as if it were a function. This is a simple, non-blocking ",(0,r.jsx)(n.strong,{children:"Command"})," and should not be awaited."]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Syntax:"})," ",(0,r.jsx)(n.code,{children:"unit(ability_id, target=None, queue=False)"})]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Behavior:"})," This call creates a ",(0,r.jsx)(n.code,{children:"UnitCommand"})," object and adds it to the internal action buffer. The library sends all buffered commands at the end of the ",(0,r.jsx)(n.code,{children:"on_step"})," execution."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Parameters:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.code,{children:"ability_id"})}),": The ",(0,r.jsx)(n.code,{children:"AbilityId"})," of the action you want to perform."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.code,{children:"target"})})," (optional): A ",(0,r.jsx)(n.code,{children:"Unit"})," or ",(0,r.jsx)(n.code,{children:"Point2"})," for targeted abilities."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.code,{children:"queue"})})," (optional ",(0,r.jsx)(n.code,{children:"bool"}),"): Controls whether the command replaces the unit's current action or is added to its command queue."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h4,{id:"deep-dive-1--the-queue-parameter",children:(0,r.jsxs)(n.strong,{children:["Deep Dive 1- The ",(0,r.jsx)(n.code,{children:"queue"})," Parameter"]})}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"queue"}),' parameter is how you chain commands together for a single unit, mimicking the "Shift-click" functionality in the game.']}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{style:{textAlign:"left"},children:"Value"}),(0,r.jsx)(n.th,{style:{textAlign:"left"},children:"Behavior"}),(0,r.jsx)(n.th,{style:{textAlign:"left"},children:"Use Case"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsxs)(n.td,{style:{textAlign:"left"},children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.code,{children:"queue=False"})})," (Default)"]}),(0,r.jsxs)(n.td,{style:{textAlign:"left"},children:[(0,r.jsx)(n.strong,{children:"Replace Current Action."})," The unit's command queue is cleared. It immediately stops what it's doing and executes this new command."]}),(0,r.jsxs)(n.td,{style:{textAlign:"left"},children:["For actions that need to happen ",(0,r.jsx)(n.em,{children:"right now"}),", like casting a critical spell or retreating a low-health unit."]})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{style:{textAlign:"left"},children:(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.code,{children:"queue=True"})})}),(0,r.jsxs)(n.td,{style:{textAlign:"left"},children:[(0,r.jsx)(n.strong,{children:"Add to Queue."})," The command is added to the end of the unit's existing command queue. The unit will finish its current task(s) before starting this new one."]}),(0,r.jsx)(n.td,{style:{textAlign:"left"},children:"For creating a sequence of actions, such as telling a worker to build three Supply Depots in a row, or telling a scout to visit multiple locations."})]})]})]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Code Example: Queuing Worker Commands"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"async def on_step(self, iteration: int):\r\n    # On the first step, give a worker a sequence of tasks.\r\n    if iteration == 0 and self.workers.exists:\r\n        worker = self.workers.first\r\n        \r\n        # Find a build location and a mineral patch.\r\n        depot_location = await self.find_placement(UnitTypeId.SUPPLYDEPOT, near=self.start_location, placement_step=5)\r\n        mineral_patch = self.mineral_field.closest_to(worker)\r\n\r\n        if depot_location and mineral_patch:\r\n            # Task 1: Build the depot (immediate action).\r\n            worker.build(UnitTypeId.SUPPLYDEPOT, depot_location)\r\n\r\n            # Task 2: After the depot is finished, start mining.\r\n            # queue=True ensures this happens *after* the build command.\r\n            worker.gather(mineral_patch, queue=True)\n"})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h4,{id:"deep-dive-2--selfget_available_abilities",children:(0,r.jsxs)(n.strong,{children:["Deep Dive 2- ",(0,r.jsx)(n.code,{children:"self.get_available_abilities()"})]})}),"\n",(0,r.jsxs)(n.p,{children:["Just checking a unit's energy is not enough. An ability might be on cooldown. ",(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.code,{children:"await self.get_available_abilities(unit)"})})," is the only reliable way to check. This is an ",(0,r.jsx)(n.code,{children:"async"})," ",(0,r.jsx)(n.strong,{children:"Query"})," that asks the game engine for a list of every ",(0,r.jsx)(n.code,{children:"AbilityId"})," a specific unit can use on the current game tick."]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h4,{id:"the-professional-ability-workflow",children:(0,r.jsx)(n.strong,{children:"The Professional Ability Workflow"})}),"\n",(0,r.jsx)(n.p,{children:"A professional bot follows a strict, four-step workflow to ensure every ability command is valid."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"(You want to use an ability...)\r\n         |\r\n         v\r\n.--- 1. SELECT CASTER ---.\r\n| `queens = self.units(QUEEN)` |\r\n`------------------------`\r\n         |\r\n         v\r\n.--- 2. CHECK PREREQUISITES ---.\r\n| - `queen.energy >= 25`         |\r\n| - `await self.get_available_abilities(queen)` |  <-- This is a QUERY\r\n`------------------------------`\r\n         | (Checks pass)\r\n         v\r\n.--- 3. FIND VALID TARGET ---.\r\n| `target = self.townhalls.closest_to(queen)` |\r\n`---------------------------`\r\n         | (Target found)\r\n         v\r\n.---- 4. ISSUE COMMAND ----.\r\n| `queen(AbilityId.EFFECT_INJECTLARVA, target)` | <-- This is a COMMAND\r\n`-------------------------`\n"})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h4,{id:"code-example--the-zerg-matriarch-bot",children:(0,r.jsx)(n.strong,{children:"Code Example- The Zerg Matriarch Bot"})}),"\n",(0,r.jsxs)(n.p,{children:["This bot demonstrates the complete workflow for using a Queen's inject ability. It uses ",(0,r.jsx)(n.code,{children:"await"})," for the ",(0,r.jsx)(n.code,{children:"get_available_abilities"})," query but correctly issues the final ",(0,r.jsx)(n.code,{children:"queen(...)"})," command without ",(0,r.jsx)(n.code,{children:"await"}),"."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'# matriarch_bot.py\r\n\r\nfrom sc2 import maps\r\nfrom sc2.bot_ai import BotAI\r\nfrom sc2.data import Difficulty, Race\r\nfrom sc2.main import run_game\r\nfrom sc2.player import Bot, Computer\r\nfrom sc2.ids.unit_typeid import UnitTypeId\r\nfrom sc2.ids.ability_id import AbilityId\r\nfrom sc2.ids.buff_id import BuffId\r\nfrom sc2.units import Units\r\nfrom sc2.unit import Unit\r\n\r\n\r\nclass MatriarchBot(BotAI):\r\n    """\r\n    Demonstrates a robust and correct workflow for using a Queen\'s inject ability,\r\n    ensuring Queens are assigned to specific Hatcheries to prevent wandering.\r\n    """\r\n\r\n    def __init__(self):\r\n        super().__init__()\r\n        # Using a dictionary to store the queen tag to hatchery tag assignment\r\n        self.queen_inject_assignment = {}\r\n\r\n    async def on_step(self, iteration: int):\r\n        await self.manage_injects()\r\n        await self.build_infrastructure()\r\n        await self.assign_inject_queens()\r\n        await self.cleanup_assignments()\r\n\r\n    async def assign_inject_queens(self):\r\n        """\r\n        Assigns idle Queens without a current task to inject a specific Hatchery.\r\n        This prevents Queens from wandering between different bases.\r\n        """\r\n        # Find queens that are idle and not already assigned to a hatchery\r\n        unassigned_queens = self.units(UnitTypeId.QUEEN).filter(\r\n            lambda q: q.tag not in self.queen_inject_assignment and q.is_idle\r\n        )\r\n        if not unassigned_queens:\r\n            return\r\n\r\n        # Find townhalls that don\'t have a queen assigned to them yet\r\n        assigned_hatchery_tags = self.queen_inject_assignment.values()\r\n        unassigned_townhalls = self.townhalls.ready.filter(\r\n            lambda th: th.tag not in assigned_hatchery_tags\r\n        )\r\n        if not unassigned_townhalls:\r\n            return\r\n\r\n        for queen in unassigned_queens:\r\n            # If there are no more unassigned townhalls, stop trying to assign queens\r\n            if not unassigned_townhalls:\r\n                break\r\n\r\n            # Find the closest unassigned townhall to the current queen\r\n            closest_th = unassigned_townhalls.closest_to(queen)\r\n\r\n            # Assign the queen to the townhall\r\n            self.queen_inject_assignment[queen.tag] = closest_th.tag\r\n\r\n            # Re-filter the collection to exclude the newly assigned townhall\r\n            unassigned_townhalls = unassigned_townhalls.filter(\r\n                lambda th: th.tag != closest_th.tag\r\n            )\r\n\r\n    async def cleanup_assignments(self):\r\n        """\r\n        Removes assignments for Queens or Hatcheries that no longer exist.\r\n        """\r\n        assignments_to_remove = []\r\n        for queen_tag, hatchery_tag in self.queen_inject_assignment.items():\r\n            # Check if the queen or hatchery is dead\r\n            if not self.units.find_by_tag(queen_tag) or not self.structures.find_by_tag(\r\n                hatchery_tag\r\n            ):\r\n                assignments_to_remove.append(queen_tag)\r\n\r\n        for tag in assignments_to_remove:\r\n            del self.queen_inject_assignment[tag]\r\n\r\n    async def manage_injects(self):\r\n        """\r\n        Manages larva injections by assigned Queens. A queen will only inject\r\n        her assigned hatchery.\r\n        """\r\n        # Iterate through the assigned queen-hatchery pairs\r\n        for queen_tag, hatchery_tag in self.queen_inject_assignment.items():\r\n            queen = self.units.find_by_tag(queen_tag)\r\n            hatchery = self.structures.find_by_tag(hatchery_tag)\r\n\r\n            # This check is now redundant due to cleanup_assignments, but good for safety\r\n            if queen is None or hatchery is None:\r\n                continue\r\n\r\n            # Check for sufficient energy\r\n            if queen.energy >= 25:\r\n                # Check if the hatchery is not already buffed\r\n                if not hatchery.has_buff(BuffId.QUEENSPAWNLARVATIMER):\r\n                    # Check if the inject ability is available for this queen\r\n                    available_abilities = await self.get_available_abilities(queen)\r\n                    if AbilityId.EFFECT_INJECTLARVA in available_abilities:\r\n                        queen(AbilityId.EFFECT_INJECTLARVA, hatchery)\r\n\r\n    async def build_infrastructure(self):\r\n        """\r\n        Manages the Zerg\'s core economic and tech infrastructure.\r\n        """\r\n        # Expand if we have less than 2 bases and are not already expanding\r\n        if (\r\n            self.townhalls.amount < 2\r\n            and self.already_pending(UnitTypeId.HATCHERY) == 0\r\n            and self.can_afford(UnitTypeId.HATCHERY)\r\n        ):\r\n            await self.expand_now()\r\n\r\n        # Build a spawning pool if we don\'t have one\r\n        if (\r\n            not self.structures(UnitTypeId.SPAWNINGPOOL).exists\r\n            and self.already_pending(UnitTypeId.SPAWNINGPOOL) == 0\r\n            and self.can_afford(UnitTypeId.SPAWNINGPOOL)\r\n        ):\r\n            if self.townhalls.ready.exists:\r\n                await self.build(\r\n                    UnitTypeId.SPAWNINGPOOL, near=self.townhalls.ready.first.position\r\n                )\r\n\r\n        # Produce one queen per hatchery\r\n        if (\r\n            self.structures(UnitTypeId.SPAWNINGPOOL).ready.exists\r\n            and (\r\n                self.units(UnitTypeId.QUEEN).amount\r\n                + self.already_pending(UnitTypeId.QUEEN)\r\n            )\r\n            < self.townhalls.amount\r\n            and self.can_afford(UnitTypeId.QUEEN)\r\n        ):\r\n            # Train a queen from a ready and idle hatchery that is not already training one\r\n            for th in self.townhalls.ready.idle:\r\n                th.train(UnitTypeId.QUEEN)\r\n\r\n\r\nif __name__ == "__main__":\r\n    run_game(\r\n        maps.get("AbyssalReefLE"),\r\n        [Bot(Race.Zerg, MatriarchBot()), Computer(Race.Terran, Difficulty.VeryEasy)],\r\n        realtime=False,\r\n    )\n'})})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(c,{...e})}):c(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>l});var i=t(6540);const r={},s=i.createContext(r);function a(e){const n=i.useContext(s);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),i.createElement(s.Provider,{value:n},e.children)}}}]);